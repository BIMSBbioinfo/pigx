import csv
import inspect
import os
import sys
import pandas as pd
import re
import magic as mg
import gzip

# ---------------------------------------------------------------------------- #
## Experiment Class
class experiment:
    def __init__(self, config = [], name="sc_rnaseq"):
        """Return an experiment object whose name is *name*"""
        self.config = config
        self.name = name

        # contains merged technical replicates
        self.merged_replicates = {}

        # sample sheet with sample descriptors
        self.SAMPLE_SHEET = []

    # ------------------------------------------------------------------------ #
    def init_SAMPLE_SHEET(self, PATH_SAMPLE_SHEET):
        """Load the SAMPLE_SHEET as csv and set the *SAMPLE_SHEET* attribute"""
        self.name = PATH_SAMPLE_SHEET
        import pandas as pd
        sample_sheet = pd.read_csv(PATH_SAMPLE_SHEET)

        self.SAMPLE_SHEET = sample_sheet
        self.validate_sheet_init()

        # appends the file locations to the input reads
        self.add_reads_path()
        self.merge_technical_replicates()

    # ------------------------------------------------------------------------ #
    # validates the data in the sample sheet
    # required column names are hardcoded
    def validate_sheet_init(self):
        """Function to validate the sample sheet"""
        #print('Validating sample sheet ...')
        sample_sheet = self.SAMPLE_SHEET

        # ----------------------------------------------------------------- #
        # Check if the required fields are found in the sample sheet
        # HARDCODED:
        required_fields = set(['sample_name', 'barcode', 'reads', 'method'])
        not_found = required_fields.difference(set(sample_sheet.columns))
        if len(not_found) > 0:
            raise Exception("ERROR: Required field(s) {} could not be found in the sample sheet file '{}'".format(not_found, self.name))

        # ----------------------------------------------------------------- #
        # Check if any of the input files are generated by unsupported single-cell rna-seq methods
        methods = set(self.config['adapter_parameters'].keys())
        message = ''
        for sample_name in sample_sheet['sample_name']:

            # check whether sample names contains strings R1/R2 - these strings should not be in the sample names
            if re.search('(R1)|(R2)', sample_name) is not None:
                message = message + 'Sample: ', + str(sample_name), 'contains R1 or R2. Please remove those strings.\n'

            sample = sample_sheet[sample_sheet.sample_name == sample_name]
            method = set(sample['method'])
            # checks whether all technical replicates have the same protocol
            if len(method) > 1:
                message = message + 'Technical replicates have differing protocols: ' + str(sample_name) + '\n'


            # Checks whether the method is allowed
            method = method.difference(methods)
            if len(method) > 0:
                message = 'Sample sheet contains unknown method: ' + str(sample_name) + " : " + str(method) + '\n'
                message = message + 'Supported methods are:' + " ".join(list(methods)) + '\n'

        # ----------------------------------------------------------------- #
        # Check that all fastq files are unique
        files = list(sample_sheet.reads) + list(sample_sheet.barcode)
        if len(files) != len(set(files)):
            raise Exception("ERROR: at least one fastq file is duplicated! The fastq files must be unique.")

        # ----------------------------------------------------------------- #
        # Checks basic properties of input files
        for index, row in sample_sheet.iterrows():
            filenames = [row.barcode,row.reads]

            for file_index in range(len(filenames)):
                filename = filenames[file_index]
                fullpath = os.path.join(self.config['locations']['reads-dir'], filename)
                # --------------------------------------------------------- #
                # Check that reads files exist
                if not os.path.isfile(fullpath):
                    raise Exception('ERROR: missing reads file: {}'.format(fullpath))

                # --------------------------------------------------------- #
                # Check that the files are gzipped
                file_type = mg.from_file(os.path.realpath(fullpath), mime=True)
                if not file_type.find('gzip') > 0:
                    message = message + 'Input file should be gzipped: ' + fullpath + '\n'

                # --------------------------------------------------------- #
                # Check that the barcode files have the desired length
                # really ugly code
                else:
                    # check whether barcode file
                    if file_index == 0:
                        adapter = self.config['adapter_parameters'][row.method]
                        adapter_length = max([adapter['cell_barcode']['base_max'], adapter['umi_barcode']['base_max']])


                        # loops over 10000 lines and checks whether the adapter length is ok; otherwise STAR will fail with hard to fish out error
                        line_ind = 0
                        with gzip.open(fullpath,'rt') as f:

                            for line in f:
                                line_ind = line_ind + 1
                                # check whether the line corresponds to sequence or quality
                                if (line_ind % 4 == 2 ) or (line_ind % 4 == 0):

                                    # adapter_length + 1 because of newline
                                    if not len(line) == (adapter_length + 1):
                                        message = message + 'Input barcode file does not have the appropriate adapter length: ' + str(adapter_length) + ' : ' + fullpath + '\n'
                                        break
                                if line_ind > 10000:
                                    break


        # ----------------------------------------------------------------- #
        # checks whether some of the samples contain errors
        if(len(message) > 0):
            raise Exception('ERROR:\n\n' + message)




    # ----------------------------------------------------------------------- #
    # pivots the sample_sheet by sample_name to get unique technical replicates
    def merge_technical_replicates(self):

        # defines the sample descriptors
        sample_sheet = pd.pivot_table(self.SAMPLE_SHEET, index='sample_name', aggfunc=list)
        sample_sheet['sample_name'] = sample_sheet.index

        column_names = set(list(self.SAMPLE_SHEET.columns))
        column_names = column_names.difference(set(['sample_name','reads','barcode','reads_path','barcode_path']))

        # checks whether all technical replicates have the same metadata
        for cname in column_names:
            cid = sample_sheet[cname]
            if(len(set(list(cid)[0])) > 1):
                sys.exit('Technical replicates have different metadata')

        # names for merged files
        sample_sheet['barcode_merged'] = sample_sheet['sample_name'] + '_R1.fastq.gz'
        sample_sheet['reads_merged']   = sample_sheet['sample_name'] + '_R2.fastq.gz'

        # names for mapped reads
        sample_sheet['mapped_reads'] = sample_sheet['sample_name'] + '.bam'

        self.merged_replicates = sample_sheet

    # ----------------------------------------------------------------------- #
    def add_reads_path(self):

        sample_sheet = self.SAMPLE_SHEET
        path_reads   = self.config['locations']['reads-dir']
        sample_sheet['barcode_path'] = self.join_path(path_reads, sample_sheet['barcode'])
        sample_sheet['reads_path'] = self.join_path(path_reads, sample_sheet['reads'])
        self.SAMPLE_SHEET = sample_sheet

    def join_path(self, path, column):

        series = []
        for file in column:
            series.append(os.path.join(path, file))

        series = pd.Series(series)
        return(series)

    # ----------------------------------------------------------------------- #
    # accessor functions for the merged technical replicates
    def fetch_sample_names(self):
        sheet = self.merged_replicates
        return(list(sheet['sample_name']))

    def fetch_field(self, sample_name, column):
        sheet = self.merged_replicates

        if not column in set(list(sheet.columns)):
            sys.exit('unindentified column selected: ' + str(column) + '\n')

        field = sheet[sheet['sample_name'] == sample_name][column]

        if field.__class__ == set:
            field = list(field[0])

        elif isinstance(field, pd.Series):
            field = list(field)[0]

        else:
            field = str(field[0])

        return(field)

    def fetch_reads(self, sample_name):
        return(list(self.fetch_field(sample_name, 'reads')))

    def fetch_reads_path(self, sample_name):
        path = self.fetch_field(sample_name, 'reads_path')
        return(path)

    def fetch_barcode(self, sample_name):
        return(list(self.fetch_field(sample_name, 'barcode')))

    def fetch_barcode_path(self, sample_name):
        path = self.fetch_field(sample_name, 'barcode_path')
        return(path)

    def fetch_column(self, column):
        return(list(self.merged_replicates[column]))
