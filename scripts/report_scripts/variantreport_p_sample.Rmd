---
title: "SARS-CoV-2 Mutations and Variant report"
nav: "Variant report"
author: "BIMSB Bioinformatics Platform"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params:
  sample_name: ''
  sigmut_db: ''
  variants_dir: ''
  vep_file: ''
  snv_file: ''
  sample_sheet: ''
  mutation_sheet: ''
  deconvolution_functions: ''
  logo: ''
---

<div id="logo" align="top">
`r knitr::include_graphics(params$logo)`
</div>

<sample>`r params$sample_name`</sample>

```{r libs, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(knitr)
library(dplyr)
library(ggplot2)
library(DT)
library(tidyr)
library(qpcR)
library(stringr)
library(magrittr)
library(base64url)
```

```{r printInputSettings, echo = FALSE}
sample_name <- params$sample_name
sample_sheet <- data.table::fread(params$sample_sheet) 
mutation_sheet <- params$mutation_sheet # not tested
location_sigmuts <- params$sigmut_db
deconvolution_functions <- params$deconvolution_functions

csv_output_dir <- params$variants_dir
date <- as.character(sample_sheet[name==sample_name]$date)
location_name <- as.character(sample_sheet[name==sample_name]$location_name)
coordinates_lat <- as.character(sample_sheet[name==sample_name]$coordinates_lat)
coordinates_long <- as.character(sample_sheet[name==sample_name]$coordinates_long)

``` 

This report shows the variant analysis of SARS-CoV-2 from wastewater samples. Mutations are 
identified by single-nucleotide-variant (SNV) calling performed by [LoFreq](https://csb5.github.io/lofreq/). 
Translated to amino acid mutations by using [Ensemble VEP - COVID-19](https://covid-19.ensembl.org/info/docs/tools/vep/index.html).
The list of found mutations (including synonymous and non-synonymous mutations) were matched against lists of 
signature mutations characterising variants of concern (VOC) of SARS-CoV-2 provided by [outbreak.info](https://outbreak.info/situation-reports) 
and [CoVariant.org](https://covariants.org/variants/S.501Y.V1).

```{r function_parse_snv_csv, include = FALSE, warning = F, message = F}
parse_snv_csv <- function (snvfile,...){ # allele frequency from v-pipe vcf
  #' input: csv file derived from vpipe vcf when using LoFreq,
  #' parsing snv-csv file for coverage, frequency and genomic mutation information
  
  snvtable <- read.table(snvfile, sep = ',', header = T)
  freq <- snvtable$AF
  cov <- snvtable$DP
  Ref <- snvtable$Ref
  Pos <- snvtable$Pos
  Var <- snvtable$Var
  
  # concat position value and nucleotides to nucleotide-mutation-notation 
  snvinfo.df <- data.frame(Ref = Ref,
                        Pos = Pos, 
                        Var = Var,
                        gene_mut = paste0(Ref, Pos, Var),
                        stringsAsFactors = FALSE)
  # concat nucleotide-mutation-notation with mutation frequencies and coverage
  # seperate posistion column will be used for joining data frames
  snv.info <- cbind(gene_pos=snvinfo.df[,"Pos"], gene_mut=snvinfo.df[,"gene_mut"],freq,cov)
  
  return(snv.info)
}

detectable_deletions <- function (x, colnames) { 
  #' deletions can span a range of position values indicated by a dash in the prot_mut_loc column.
  #' In those cases those ranges have to be split up in order to be able to detect single positions. This function should
  #' be used on a already filtered set of deletions derived from the vep-output. They are then split up and expanded with the 
  #' number of rows realted to the number of position. The function returns those extended lines as a dataframe which structure
  #' is matching the df structure which is returned by "get_protein_mut" 
  
  # check that the mutations spans multiple nucleotides AND multiple Amino Acids
  if (x['gene_mut_loc.2'] != x['gene_mut_loc.3'] & str_detect(x['prot_mut_loc'],"-")){
  
    # extract columns from input dataframe where the content of the rows won't change, but where rows will be duplicated 
    # when merging back with the extended deletion rows
    constant_before <- as.data.frame((cbind(x['gene_mut_loc.1'], x['gene_mut_loc.2'], x['gene_mut_loc.3'])))
    constant_after <- as.data.frame((cbind(x['Conseq'],x['genes'])))
  
    # split the position values denoting a range and make as many new rows as positions spanned with the missing 
    # position values e.g: 1-3 (1 row) will become 1,2,3 (3 rows)
    split_prot_pos <- str_split(x['prot_mut_loc'],"-")
    list_prot_pos <- list()
    for (i in 1:length(split_prot_pos)){
      list_prot_pos[[i]] <- seq(as.numeric(split_prot_pos[[i]][1]),as.numeric(split_prot_pos[[i]][2]))
    }
    
    # TODO instead of qpcR bind_cols from dplyer
    # split groups of reference Amino acids (AAs.1) if necessary, concat the extendet columns
    extendet <- as.data.frame(qpcR:::cbind.na(as.character(unlist(list_prot_pos)), as.character(unlist(str_split(x['AAs.1'],''))), as.character(str_split(x['AAs.2'],''))))
    # the dash is the sign for an Amino Acid that was deleted
    extendet[is.na(extendet)] <- '-' 
    
    # join the columns with the extended rows back with the rest of the original dataframe
    full <- as.data.frame(cbind(constant_before,extendet, constant_after))
    colnames(full) <- colnames
    # match the extended rows with added positions values to the Amino acids. If a group of reference Amino acids in AAs.1
    # is given it's splitted and matched according to their order. The mutation in AAs.2 is only applied to the last position
    # every other position get's an dash in column AAs.2
    # e.g.: 1-3 is exended to seperate rows, if htere was ABC in AAs.1 and C in AAs.2, the results would be A1-, B2-, C3C
    full$prot_mut_loc <- vapply(full$prot_mut_loc, paste, collapse = " ", character(1L))
    full$AAs.1 <- vapply(full$AAs.1, paste, collapse = " ", character(1L))
    full$AAs.2 <- vapply(full$AAs.2, paste, collapse = " ", character(1L))
    
    return(full)
  }
  
}

get_protein_mut <- function (vepfile){ # parse together from vep output "Protein_position" and "Amino_acid"
  #' input: []_sarscov2_parsed.txt, parsed vcf from VEP CLI, comma seperated
  #' this function is for parsing the information about mutation position in the amino acid sequence, the reference aa and
  #' the alternative mutation into the aa-mutation-notation which is later on comparable to the lists of signature mutations
  
  # reading in whole vep txt output
    vepfile.df <- read.table(vepfile, sep = ',', header = T) # you should include in the vep script to parse out the # 
      #in the beginning of the line or include that step here. 
     # parsing snv and protmut location
  
    # parsing gene mutation
    gene_mutation <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
                                nucleotides = str_split_fixed(
                                                str_split_fixed(vepfile.df$Uploaded_variation, 
                                                                "[_-]+", n=4) [,4], "/", n=2))
    gene_mutation$gene_mut <- paste0(gene_mutation$nucleotides.1, gene_mutation$gene_mut_loc.2, gene_mutation$nucleotides.2)
  
    # parsing snv and protmut location
    locations <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
                            gene_mut = gene_mutation$gene_mut,
                            prot_mut_loc = vepfile.df$Protein_position, 
                            AAs = str_split_fixed(vepfile.df$Amino_acids, "/",2), 
                            Conseq = vepfile.df$Consequence,
                            genes = vepfile.df$SYMBOL)
    locations <- dplyr::na_if(locations,'')
    
    # delete all rows with no protein position value
    locations <- distinct(locations %>% filter(!grepl("^-", prot_mut_loc)))
    # specific B117 mutations: 21990-21993, 21764-21770, maybe also 3675-3677, 69-70 - all there
  
    deletions.df <- locations
    deletions.df <- locations %>%
                        filter(gene_mut_loc.2 != gene_mut_loc.3 &
                                Conseq == "inframe_deletion" &
                                str_detect(deletions.df$prot_mut_loc,"-"))
    colnames <- colnames(deletions.df)
    
    # if there is a deletion the snv would span a couple of positions, if there is not such a spanning region there are no deletions
    # ! 06/05/2021 Vic - I think, I don't know how robust this is, but it will work for the sig mutations we have so far
    if ( nrow(locations) >=1 && !(any(is.na(locations[,'gene_mut_loc.3'])))) {
        deletions <- dplyr::bind_rows(apply(deletions.df,1, detectable_deletions, colnames = colnames))
        locations <- dplyr::bind_rows(locations,deletions)
    }
  
  # substitute "nothing" at alternative-aa-column (for deletions) with "-"
  locations$AAs.2[is.na(locations$AAs.2)] <- "-"
  # clean - characters 
  locations$AA_mut <- paste(locations$AAs.1,locations$prot_mut_loc,locations$AAs.2, sep = "")
  # adding gene information
  
  
  return(locations)
}


dedupeMuts <- function (mut, sigmut.df, dedup.df) {
        #' this function is a different version of "dedupe" 
        #' if a signature mutation is shared by multiple variants the mutation-tables
        #' would have seperate rows for the same mutation. This function is for concatenating all the variants 
        #' that share that mutation. It requires the original df with all mutations, the deduplicated one 
        #' (only one row per mutation) and the mutation for which this procedure should be applied
        #' This function is not yet completely refined and should be improved further
        # get variant group per mutation
        duped_muts <- grep (mut, sigmut.df$value)
        grouped <- sigmut.df$name[duped_muts]
        groupName <- paste(grouped, collapse = ",")
      
        dedup.df$name[dedup.df$value == mut] <- groupName
        return (dedup.df)
}  
```

```{r process_signature_mutations, message=F, warning=F, include = FALSE}

# Read signature data
# TODO: these should probably all be declared inputs.
sigmuts <- list(list(file="B117_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b117"),
                list(file="B1351_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1351"),
                list(file="B1427_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1427"),
                list(file="B1429_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1429"),
                list(file="B1526_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1526"),
                list(file="P1_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="p1"),
                list(file="B16172_outbreakinfo_mutation_report_data_2021-05-26.tsv",
                     name="b16172"))

read_sigmuts <- function (sigmut) {
    file <- sigmut$file

    data <- read.table(file.path(location_sigmuts, file),
                       sep = "\t", header = TRUE)
    # modify deletions, substitute "nothing" with a dash e.g: D789 -> D789-
    data$alt_aa <- na_if (data$alt_aa, "")
    data$alt_aa[is.na(data$alt_aa)] <- "-"

    # Paste column with correct prot mutation notation
    data$AA_mut <- paste0(data$ref_aa, data$codon_num, data$alt_aa)

    # Return a table mapping strain name to mutation
    data.frame(name = sigmut$name,
               value = data$AA_mut)
}

sig_mutations.df <- do.call(rbind, lapply(sigmuts, read_sigmuts))

vepfile.df <- read.table(params$vep_file, sep = ",", header = T) 

vepfile.df <- na_if(vepfile.df, "-")

# deduplicate dataframe
# reasoning see description of "dedupeMuts"
# fixme: I was not sure, how I can include this in my function but should be possible, will come back to it later
dupes <- duplicated (sig_mutations.df$value, fromLast=TRUE)
allDupes <- dupes | duplicated (sig_mutations.df$value, fromLast=FALSE)

if (any (allDupes)) {
    sigmuts_deduped <- sig_mutations.df[!dupes,]
}

# fixme: I think this should be done with some apply() function? 
for (mut in sig_mutations.df$value) {
  sigmuts_deduped <- dedupeMuts(mut, sig_mutations.df, sigmuts_deduped)
}

```

```{r match_snvs_to_signature_mutations, message=F, warning=F, include = FALSE}
variant_protein_mut <- get_protein_mut(params$vep_file)
# match the variant names according to the signature mutations, if there is no signature mutation no name will be given
variant_protein_mut <- dplyr::left_join(variant_protein_mut, sigmuts_deduped, by = c('AA_mut'='value'))
# filter for mutations which are signature mutations
match.df <- variant_protein_mut %>%
                    filter(!is.na(name))
# filter for everything that is not a signature mutation
nomatch.df <- variant_protein_mut %>%
                        filter(is.na(name))
```

```{r merge_vep_with_lofreq_info, message=F, warning=F, include = FALSE}
# get the SNV frequency values and coverage information for the mutations from the LoFreq output
lofreq.info <- as_data_frame(parse_snv_csv(params$snv_file)) 
vep.info <- variant_protein_mut

complete.df <- dplyr::left_join(lofreq.info, vep.info, by = c('gene_mut'='gene_mut'), copy = T)
# one aa mutation can have different codon mutations reported with different freqs- those have to be summed up
complete.df <- complete.df %>%
  group_by(across(c(-freq,-gene_mut,AA_mut))) %>%
  summarise(freq = sum(as.numeric(freq)), gene_mut = paste(gene_mut, collapse = ",")) %>%
  ungroup()

match.df <- complete.df %>%
                    filter(!is.na(name))
nomatch.df <- complete.df %>%
                        filter(is.na(name))
```

# Mutations matching variants of concern

The following tables list the called SNVs. Table 1 shows the mutations matching signature mutations for given SARS-CoV-2 
variants. Table 2 shows all other mutations without any match. The columns are described as follows:

1. **SNV** -- nucleotide mutation in the pattern of: reference base, position nucleotide sequence, mutation base 
2. annotated gene
3. translated amino acid (AA) mutation in the pattern of: reference AA, position AA sequence, mutation AA
    * a asterix `*` denotes a stop codon
    * a dash `-` denotes a deletion
4. variant of concern which is described by this mutation
5. reported allele frequency
6. read coverage of that particular mutation

```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 1: SNVs from sample matching signature mutations")
```
```{r sig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
# Display the filtered signature mutations and the variants accordingly in scrollable tables

SignatureTable <-  data.frame("SNV" = match.df$gene_mut, 
                  "gene" = match.df$genes,
                  "protein_mutation" = match.df$AA_mut,
                  "variant" = match.df$name, # TODO: more nice writing of it e.g B1.1.7            
                  "frequency" = match.df$freq, # TODO: more clear name stating which frequency
                  "coverage" =  match.df$cov) # TODO: more clear title stating which coverage 
DT::datatable(SignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 180,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```
```{r nonsig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 2: SNVs from sample not matching any signature mutations")
```
```{r non_sig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
# Display the filtered signature mutations and the variants accordingly in scrollable tables

NoSignatureTable <-  data.frame("SNV" = nomatch.df$gene_mut, 
                  "gene" = nomatch.df$genes,
                  "protein_mutation" = nomatch.df$AA_mut,
                  "frequency" = nomatch.df$freq, # TODO more clear name stating which frequency
                  "coverage" =  nomatch.df$cov) # TODO more clear title stating which coverage
DT::datatable(NoSignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 400,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```

# Deconvolution

Deconvolution is done by using robust regression. It relies on signature mutations of each variant. It aims 
to predict the individual contributions of the variants of concern to the observed mutation frequencies in the bulk 
wastewater sample.

```{r getting_unique_muts_bulk, message=F, warning=F, include = FALSE}

# get prot.mutations only, input for the signature matrix 
mutations.vector <- c(match.df$AA_mut)
# get bulk frequency values, will be input for the deconvolution function
bulk_freq.vector <- as.numeric(match.df$freq)

# only execute the deconvolution when at least one signature mutation was found
executeDeconvolution <- length(mutations.vector) > 0
```


```{r creating_signature_matrix, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
source(deconvolution_functions) # TODO should be given as input with the params section
# create an empty data frame add a column for the Wildtype
# Wildtype in this case means the reference version of SARS-Cov-2
msig_simple <- createSigMatrix(mutations.vector, mutation_sheet)

# for the deconvolution to work we need the "wild type" frequencies too. The matrix from above got mirrored, 
# wild type mutations are simulated the following: e.g. T210I (mutation) -> T210T ("wild type")
msig_simple <- createSigMatrix(mutations.vector, mutation_sheet)
msig_stable_all <- simulateWT( mutations.vector, bulk_freq.vector, msig_simple)
msig_stable <- msig_stable_all[[1]]

```


```{r collapse_identicals, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
source(deconvolution_functions)
# When multiple columns look like the same, the deconvolution will not work, because the function can't distinguish 
# between those columns. The workaround for now is to identify those equal columns and merge them into one, returning also
# a vector with the information about which of the columns were merged. 

msig_transposed <- dedupeDF( msig_stable )

msig_stable_transposed <- msig_transposed[[1]]
msig_dedupe_transposed <- msig_transposed[[2]]

for (variant in rownames( msig_stable_transposed[-(row.names(msig_stable_transposed) %in% 'muts'),] )) {
  msig_dedupe_transposed <- dedupeVariants(variant, msig_stable_transposed, msig_dedupe_transposed)
}

if ( length(msig_dedupe_transposed) >= 1){ 
    msig_stable_unique <- as.data.frame(t(msig_dedupe_transposed[,-1])) # the 1 get's rid of the additional first row which is an transposing artifact
}


```
```{r deconvolution, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
source(deconvolution_functions)

# this hack is necessary because otherwise the deconvolution will throw: Error in x * wts: non-numeric argument to binary operator
# also see: https://stackoverflow.com/questions/37707060/converting-data-frame-column-from-character-to-numeric/37707117
sig <- apply(msig_stable_unique[,-which(names(msig_stable_unique) %in% 'muts')], 2 , function(x) {
              as.numeric(as.character(x)) })

bulk_all <- as.numeric(msig_stable_all[[2]])

variant_abundance <- deconv(bulk_all,sig)

```
`r if (executeDeconvolution){"The following bar plot shows the percentage of each VOCs in the sample as predicted by the
deconvolution model. If it is not possible to identify a unique VOC from the reported mutation, 
the column description shows all VOCs which are realted to the signature mutation."}` 

```{r plot, message=F, warning=F, echo = FALSE, eval = executeDeconvolution}

Variant_colors <- c("#8a3874", "#4d3da1", "#62c742", "#13317a", "#86e5a3", "#6f69e5", "#4cdab2", "#999ce4", "#2ce6f3",
"#6638c6", "#005f29", "#5d73cc", "#616524", "#a8a041", "#e9f600", "#3eaca8", "#62a273", "#4ea5d0", "#655c95", "#67a04e")
# TODO this shoul be put into a seperate color palette function in a seperate file

# work in progress...only to show how it theoretically can look like in the report
variants <- colnames(msig_stable_unique[,-1])
df <- data.frame(rbind(variant_abundance))

# XXX: Replace the long column name consisting of concatenated variant
# names with "others" and put the variant names in a label.
# TODO: This should be done much earlier when building the data frame.

condensed_variants_names <-
    unlist(lapply(variants, function (x) { if (str_detect(x, ".*,.*,.*")) { "others" } else { x }}))

colnames(df) <- condensed_variants_names

variants_labels <-
    unlist(lapply(variants, function (x) str_replace_all(x, ",", "\n")))

df <- df %>% 
    tidyr::pivot_longer(everything())

font_family <- "DejaVu Sans"

 ggplot(data = df, aes(name,value, 
                       fill = name)) +
        geom_bar(stat="identity") +
        labs(title = "Proportion of variants of concern inferred from deconvolution",
             x = "Variants",
             y = "Percentage") +
        scale_x_discrete(limits = condensed_variants_names) +
        scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.1),
                           labels = scales::percent_format(accuracy = 1)) +
        scale_colour_manual(values=Variant_colors) + 
        # geom_text ignores the theme's default font family, so we
        # need to provide it here.
        geom_text(aes(family = font_family,
                      label = sprintf("%0.3f", round(value, digits = 3))),
                      position=position_dodge(width=0.9), 
                      vjust=-0.25) + 
     scale_fill_discrete(name = "Variants",
                         breaks = condensed_variants_names,
                         labels = variants_labels) +
     theme_gray(base_family = font_family)
```

# Methods
## LoFreq filter
| LoFreq is used with default filter settings:       |                   |
|:---------------------------------------------------|:------------------|
| minimum coverage                                   | 10                |
| Strand-Bias Multiple Testing Correction, fdr corr. | pvalue > 0.001000 |
| Minimum SNV Quality (Phred)                        | 63                |
| Minimum Indel Quality (Phred)                      | 47                |

## VEP settings  
* Species: SARS-CoV-2  
* Assembly: ASM985889v3  

|                                                   |        |
|:--------------------------------------------------|:-------|
| Matched Annotations from NCBI and EMBL-EBI (MANE) | yes    |
| Restrict results by severity of consequence       | no     |
| upstream/downstream distance                      | 5000bp |


# Raw data 

```{r download_raw, include = F}
# make raw/input data downloadable
snvs <- readLines(params$snv_file) %>% paste0(collapse="\n") %>% base64_urlencode()
vep <- readLines(params$vep_file) %>% paste0(collapse="\n") %>% base64_urlencode()
```
Called SNVs:  
[Download SNVs.csv](`r sprintf('data:text/csv;base64,%s', snvs)`)

Variant effect prediction (*Ensemble VEP output*):  
[Download VEP_out.csv](`r sprintf('data:text/csv;base64,%s', vep)`)

```{r csv_output_variant_plot, include = F, eval = executeDeconvolution}
# prepare processed variant values to output them as a csv which will be used for the plots in index.rmd
# those outputs are not offically declared as outputs which can lead to issues - that part should be handled by a seperate 
# file (and maybe rule)
# get all possible variants
all_variants <- colnames (msig_stable[, -which( names(msig_stable) %in% "muts" )])
output_variants <- file.path(csv_output_dir, "data_variant_plot.csv")

# if file exists already - grep the existing content and add a new line
if (file.exists (output_variants)) {
    output_variant_plot <- read.table (output_variants, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_variant_plot <- data.frame (samplename = character(), 
                                       dates = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (variant in all_variants) {
      output_variant_plot[,variant] <- numeric()
    }
    
  #write header line
  write.table(t(colnames(output_variant_plot)), output_variants, sep = "\t", 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
}
# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_variant_plot <- bind_rows(output_variant_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_variant_plot$samplename))

# write deconv values to df
for (i in all_variants){
  if (i %in% df$name){
    # check if variant already has a column
    if (i %in% colnames(output_variant_plot)) {
        output_variant_plot[sample_row,][i] <- df$value[df$name == i]
    }
  }
}
write.table(output_variant_plot[sample_row,], output_variants, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
```{r csv_output_mutation_plot, message = FALSE, warning = FALSE, include = FALSE}
# prepare processed mutation values to output them as a csv which will be used for the plots in index.rmd
# those outputs are not offically declared as outputs which can lead to issues - that part should be handled by a seperate 
# file (and maybe rule)
 
# only one mutation disregarding variants
# TODO: that problem should be fixed already further above by deduplicating for the tables, check and consider that 
# data frame from above
match.df <- unique(match.df)
# get all possible mutations
all_mutations <- sigmuts_deduped$value
output_mutations <- file.path(csv_output_dir, "data_mutation_plot.csv")


if (file.exists (output_mutations)) {
    output_mutation_plot <- read.table (output_mutations, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_mutation_plot <- data.frame (samplename = character(),
                                       dates = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (mutation in all_mutations) {
      output_mutation_plot[,mutation] <- numeric()
    }
    #write header line
    write.table(t(colnames(output_mutation_plot)), output_mutations, sep = "\t", 
                  row.names = FALSE, col.names = FALSE, quote = FALSE)
}

# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_mutation_plot <- bind_rows(output_mutation_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_mutation_plot$samplename))

# write mutation frequency values to df
for (i in all_mutations){
  if (i %in% match.df$AA_mut){
    # check if variant already has a column
    if (i %in% colnames(output_mutation_plot)) {
        output_mutation_plot[sample_row,][i] <- match.df$freq[match.df$AA_mut == i]
    }
  }
}
write.table(output_mutation_plot[sample_row,], output_mutations, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
