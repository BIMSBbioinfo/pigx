---
title: "SARS-CoV-2 Mutations and Variant report"
nav: "Variant report"
author: "BIMSB Bioinformatics Platform"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params:
  sample_name: ''
  sigmut_db: ''
  variants_dir: ''
  vep_file: ''
  snv_file: ''
  sample_sheet: ''
  logo: ''
---

<div id="logo" align="top">
`r knitr::include_graphics(params$logo)`
</div>

<sample>`r params$sample_name`</sample>

```{r libs, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(knitr)
library(dplyr)
library(ggplot2)
library(DT)
library(tidyr)
library(qpcR)
library(stringr)
library(magrittr)
library(base64url)
```

```{r printInputSettings, echo = FALSE}
sample_name <- params$sample_name
sample_sheet <- data.table::fread(params$sample_sheet)
location_sigmuts <- params$sigmut_db

csv_output_dir <- params$variants_dir
date <- as.character(sample_sheet[name==sample_name]$date)
location_name <- as.character(sample_sheet[name==sample_name]$location_name)
coordinates_lat <- as.character(sample_sheet[name==sample_name]$coordinates_lat)
coordinates_long <- as.character(sample_sheet[name==sample_name]$coordinates_long)

``` 

This report shows the variant analysis of SARS-CoV-2 from wastewater samples. Mutations are 
identified by single-nucleotide-variant (SNV) calling performed by [LoFreq](https://csb5.github.io/lofreq/). 
Translated to amino acid mutations by using [Ensemble VEP - COVID-19](https://covid-19.ensembl.org/info/docs/tools/vep/index.html).
The list of found mutations (including synonymous and non-synonymous mutations) were matched against lists of 
signature mutations characterising variants of concern (VOC) of SARS-CoV-2 provided by [outbreak.info](https://outbreak.info/situation-reports) 
and [CoVariant.org](https://covariants.org/variants/S.501Y.V1).

```{r function_parse_snv_csv, include = FALSE, warning = F, message = F}
parse_snv_csv <- function (snvfile,...){ # allele frequency from v-pipe vcf
  #' input: csv file derived from vpipe vcf when using LoFreq,
  #' parsing snv-csv file for coverage, frequency and genomic mutation information
  
  snvtable <- read.table(snvfile, sep = ',', header = T)
  freq <- snvtable$AF
  cov <- snvtable$DP
  Ref <- snvtable$Ref
  Pos <- snvtable$Pos
  Var <- snvtable$Var
  snvinfo.df <- data.frame(Ref = Ref,
                        Pos = Pos, 
                        Var = Var,
                        gene_mut = paste0(Ref, Pos, Var),
                        stringsAsFactors = FALSE)
  snv.info <- cbind(gene_pos=snvinfo.df[,"Pos"], gene_mut=snvinfo.df[,"gene_mut"],freq,cov)
  
  return(snv.info)
}

get_protein_mut <- function (vepfile){ # parse together from vep output "Protein_position" and "Amino_acid"
  
  # reading in whole vep txt output
    vepfile.df <- read.table(vepfile, sep = ',', header = T) # you should include in the vep script to parse out the # 
      #in the beginning of the line or include that step here. 
    
    # parsing snv and protmut location
    locations <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
                            prot_mut_loc = vepfile.df$Protein_position, 
                            AAs = str_split_fixed(vepfile.df$Amino_acids, "/",2), 
                            Conseq = vepfile.df$Consequence,
                            genes = vepfile.df$SYMBOL)
    locations <- dplyr::na_if(locations,'')
    
    # delete all rows with no protein position value
    locations <- locations %>% filter(!grepl("^-", prot_mut_loc))
    # specific B117 mutations: 21990-21993, 21764-21770, maybe also 3675-3677, 69-70 - all there
    
    
    detectable_deletions <- function (x, colnames) { 
      
      if (x['gene_mut_loc.2'] != x['gene_mut_loc.3'] & str_detect(x['prot_mut_loc'],"-")){
      
        constant_before <- as.data.frame((cbind(x['gene_mut_loc.1'], x['gene_mut_loc.2'], x['gene_mut_loc.3'])))
        constant_after <- as.data.frame((cbind(x['Conseq'],x['genes'])))
      
        split_prot_pos <- str_split(x['prot_mut_loc'],"-")
        list_prot_pos <- list()
        for (i in 1:length(split_prot_pos)){
          list_prot_pos[[i]] <- seq(as.numeric(split_prot_pos[[i]][1]),as.numeric(split_prot_pos[[i]][2]))
        }
        
        extendet <- as.data.frame(qpcR:::cbind.na(as.character(unlist(list_prot_pos)), as.character(unlist(str_split(x['AAs.1'],''))), as.character(str_split(x['AAs.2'],''))))
        extendet[is.na(extendet)] <- '-' 
        
        full <- as.data.frame(cbind(constant_before,extendet, constant_after))
        colnames(full) <- colnames
        full$prot_mut_loc <- vapply(full$prot_mut_loc, paste, collapse = " ", character(1L))
        full$AAs.1 <- vapply(full$AAs.1, paste, collapse = " ", character(1L))
        full$AAs.2 <- vapply(full$AAs.2, paste, collapse = " ", character(1L))
        
        return(full)
      }
      
    }
    deletions.df <- locations
    deletions.df <- locations %>%
                        filter(gene_mut_loc.2 != gene_mut_loc.3 &
                                Conseq == "inframe_deletion" &
                                str_detect(deletions.df$prot_mut_loc,"-"))
    colnames <- colnames(deletions.df)
    
    # if there is a deletion the snv would span a couple of positions, if there is not such a spanning region there are no deletions
    # ! 06/05/2021 Vic - I think, I don't know how robust this is, but it will work for the sig mutations we have so far
    if (!(any(is.na(locations[,'gene_mut_loc.3'])))) {
        deletions <- dplyr::bind_rows(apply(deletions.df,1, detectable_deletions, colnames = colnames))
        locations <- dplyr::bind_rows(locations,deletions)
    }
  
  # substitute "nothing" at alternative-aa-column (for deletions) with "-"
  locations$AAs.2[is.na(locations$AAs.2)] <- "-"
  # clean - characters 
  locations$AA_mut <- paste(locations$AAs.1,locations$prot_mut_loc,locations$AAs.2, sep = "")
  # adding gene information
  
  
  return(locations)
}

deconv <- function (bulk,sig){
  
  rlm_model = suppressWarnings(MASS::rlm(sig,bulk, maxit = 100))
      
      
  rlm_coefficients = rlm_model$coefficients
  
  rlm_coefficients = ifelse(rlm_coefficients < 0, 0, rlm_coefficients)
  
  sumOfCof = sum(rlm_coefficients)
  
  rlm_coefficients = rlm_coefficients / sumOfCof  #normalize so coefficients add to 1
  
  as.vector(rlm_coefficients)
}

dedupe <- function (df) {
    transposed <- t (df)
    dupes <- duplicated (transposed, fromLast=TRUE)
    allDupes <- dupes | duplicated (transposed, fromLast=FALSE)
    if (any (allDupes)) {
        grouped <- colnames (df)[allDupes]
        groupName <- paste(grouped, collapse = ",")
        deduped <- df[!dupes]
        names (deduped)[names (deduped) %in% grouped] <- groupName
        return (deduped)
    } else {
        return (df)
    }
}

dedupeMuts <- function (mut, sigmut.df, dedup.df) {
        # get variant group per mutation
        duped_muts <- grep (mut, sigmut.df$value)
        grouped <- sigmut.df$name[duped_muts]
        groupName <- paste(grouped, collapse = ",")
      
        dedup.df$name[dedup.df$value == mut] <- groupName
        return (dedup.df)
}  
```

```{r process_signature_mutations, message=F, warning=F, include = FALSE}

# Read signature data
# TODO: these should probably all be declared inputs.
sigmuts <- list(list(file="B117_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b117"),
                list(file="B1351_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1351"),
                list(file="B1427_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1427"),
                list(file="B1429_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1429"),
                list(file="B1526_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1526"),
                list(file="P1_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="p1"),
                list(file="B16172_outbreakinfo_mutation_report_data_2021-05-26.tsv",
                     name="b16172"))

read_sigmuts <- function (sigmut) {
    file <- sigmut$file

    data <- read.table(file.path(location_sigmuts, file),
                       sep = "\t", header = TRUE)
    # modify deletions, substitute "nothing" with a dash e.g: D789 -> D789-
    data$alt_aa <- na_if (data$alt_aa, "")
    data$alt_aa[is.na(data$alt_aa)] <- "-"

    # Paste column with correct prot mutation notation
    data$AA_mut <- paste0(data$ref_aa, data$codon_num, data$alt_aa)

    # Return a table mapping strain name to mutation
    data.frame(name = sigmut$name,
               value = data$AA_mut)
}

sig_mutations.df <- do.call(rbind, lapply(sigmuts, read_sigmuts))

vepfile.df <- read.table(params$vep_file, sep = ",", header = T) #TODO - in na's umwandeln

vepfile.df <- na_if(vepfile.df, "-")

# deduplicate dataframe
# fixme: I was not sure, how I can include this in my function but should be possible, will come back to it later
dupes <- duplicated (sig_mutations.df$value, fromLast=TRUE)
allDupes <- dupes | duplicated (sig_mutations.df$value, fromLast=FALSE)

if (any (allDupes)) {
    sigmuts_deduped <- sig_mutations.df[!dupes,]
}

# fixme: I think this should be done with some apply() function? 
for (mut in sig_mutations.df$value) {
  sigmuts_deduped <- dedupeMuts(mut, sig_mutations.df, sigmuts_deduped)
}

```

```{r match_snvs_to_signature_mutations, message=F, warning=F, include = FALSE}
variant_protein_mut <- get_protein_mut(params$vep_file)
variant_protein_mut <- dplyr::left_join(variant_protein_mut, sigmuts_deduped, by = c('AA_mut'='value'))
match.df <- variant_protein_mut %>%
                    filter(!is.na(name))
nomatch.df <- variant_protein_mut %>%
                        filter(is.na(name))
```

```{r, message=F, warning=F, include = FALSE}
# Data frame to use for the tables
lofreq.info <- as_data_frame(parse_snv_csv(params$snv_file))
# vep.info <- write the part that returns the variant_protein_mut into a function 
vep.info <- variant_protein_mut
# add freqency and coverage information to protein mutations
#variant_protein_mut <- dplyr::left_join(variant_protein_mut, sig_mutations.df, by = c('AA_mut'='value'))
complete.df <- dplyr::left_join(lofreq.info, vep.info, by = c('gene_pos'='gene_mut_loc.2'), copy = T)
match.df <- complete.df %>%
                    filter(!is.na(name))
nomatch.df <- complete.df %>%
                        filter(is.na(name))
```

# Mutations matching variants of concern

The following tables list the called SNVs. Table 1 shows the mutations matching signature mutations for given SARS-CoV-2 
variants. Table 2 shows all other mutations without any match. The columns are described as follows:

1. **SNV** -- nucleotide mutation in the pattern of: reference base, position nucleotide sequence, mutation base 
2. annotated gene
3. translated amino acid (AA) mutation in the pattern of: reference AA, position AA sequence, mutation AA
    * a asterix `*` denotes a stop codon
    * a dash `-` denotes a deletion
4. variant of concern which is described by this mutation
5. reported allele frequency
6. read coverage of that particular mutation

```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 1: SNVs from sample matching signature mutations")
```
```{r sig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
SignatureTable <-  data.frame("SNV" = match.df$gene_mut, 
                  "gene" = match.df$genes,
                  "protein_mutation" = match.df$AA_mut,
                  "variant" = match.df$name, # maybe more nice writing of it e.g B1.1.7            
                  "frequency" = match.df$freq, # maybe more clear name stating which frequency
                  "coverage" =  match.df$cov) # maybe more clear title stating which coverage 
DT::datatable(SignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 180,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```
```{r nonsig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 2: SNVs from sample not matching any signature mutations")
```
```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
NoSignatureTable <-  data.frame("SNV" = nomatch.df$gene_mut, 
                  "gene" = nomatch.df$genes,
                  "protein_mutation" = nomatch.df$AA_mut,
                  "frequency" = nomatch.df$freq, # maybe more clear name stating which frequency
                  "coverage" =  nomatch.df$cov) # maybe more clear title stating which coverage
DT::datatable(NoSignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 400,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```
# Deconvolution 
Deconvolution is done by using robust regression. It relies on signature mutations of each variant. It aims 
to predict the individual contributions of the variants of concern to the observed mutation frequencies in the bulk 
wastewater sample.

```{r getting_unique_muts_bulk, message=F, warning=F, include = FALSE}

# get prot.mutations only 
muts <- c(match.df$AA_mut)
# get bulk frequency values
bulk <- as.numeric(match.df$freq)

executeDeconvolution <- length(muts) > 0
```


```{r creating_signature_matrix_simple, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
# create an empty data frame add a column for the Wildtype
msig <- data.frame(muts,WT=0,b117=0,b1351=0,b1427=0,b1429=0,b1526=0,p1=0, b16172=0)

# make sigmuts per variant tables new with parsed mutations

b117 <- filter(sig_mutations.df, name == "b117")$value
msig[msig$muts %in% b117,"b117"]=1

b1351 <- filter(sig_mutations.df, name == "b1351")$value
msig[msig$muts %in% b1351,"b1351"]=1

b1427 <- filter(sig_mutations.df, name == "b1427")$value
msig[msig$muts %in% b1427,"b1427"]=1

b1429 <- filter(sig_mutations.df, name == "b1429")$value
msig[msig$muts %in% b1429,"b1429"]=1

b1526 <- filter(sig_mutations.df, name == "b1526")$value
msig[msig$muts %in% b1526,"b1526"]=1

p1 <- filter(sig_mutations.df, name == "p1")$value
msig[msig$muts %in% p1,"p1"]=1

b16172 <- filter(sig_mutations.df, name == "b16172")$value
msig[msig$muts %in% b16172, "b16172"]=1

msig[1,2] <- 0 # put the WT signature, here it's 0 and not 1 bc it will be inversed in the next step
```
```{r adding_wt_to_sigmat, message=F, warning=F, include = FALSE, eval = executeDeconvolution}

# making the WT rows

# 1. make "WT mutations" 
muts_wt <- lapply(muts,function(x) str_replace(x,regex(".$"), str_sub(x, 1,1)))
muts_wt.df <- data.frame(muts = unlist(muts_wt))
# 2. make frequency values, subtract the observed freqs for the real mutations from 1
bulk_wt <- lapply(bulk, function (x) {1-x})

# 3. make matrix with wt mutations and inverse the values and wild type freqs
msig_inverse <- bind_cols(muts_wt.df, as.data.frame(+(!msig[,-1])))

# fixme: not sure if this really is a nice way to concat those things...
muts_all <- c(muts_wt,muts)
muts_all.df <- data.frame(muts = unlist(muts_all))

bulk_all <- c(bulk_wt, bulk)
bulk_all.df <- data.frame(freq = unlist(bulk_all))

msig_all <- rbind(msig_inverse[,-1],msig[,-1])

# 4. concat the data frames

# without bulk freq for building the signature matrix
msig_stable <- bind_cols(muts_all.df,msig_all)

# with bulk freq for export and overview
msig_stable_complete <- bind_cols(muts_all.df,msig_all,bulk_all.df)
```


```{r collapse_identicals, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
# When multiple columns look like the same, the deconvolution will not work, because the function can't distinguish 
# between those columns. The workaround for now is to identify those equal columns and merge them into one, returning also
# a vector with the information about which of the columns were merged. 

msig_stable_unique <- dedupe(msig_stable)

```
```{r deconvolution, message=F, warning=F, include = FALSE, eval = executeDeconvolution}

sig <- msig_stable_unique[,-1]
variant_abundance <- deconv(as.numeric(bulk_all),sig)

```
`r if (executeDeconvolution){"The following bar plot shows the percentage of each VOCs in the sample as predicted by the
deconvolution model. If it is not possible to identify a unique VOC from the reported mutation, 
the column description shows all VOCs which are realted to the signature mutation."}` 

```{r plot, message=F, warning=F, echo = FALSE, eval = executeDeconvolution}

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# work in progress...only to show how it theoretically can look like in the report
variants <- colnames(msig_stable_unique[,-1])
df <- data.frame(rbind(variant_abundance))
colnames(df) <- variants
df <- df %>% 
    tidyr::pivot_longer(everything())

 ggplot(data = df, aes(name,value, 
                       fill = name)) +
        geom_bar(stat="identity") +
        labs(title = "Proportion of variants of concern inferred from deconvolution",
             x = "Variants",
             y = "Percentage") +
        scale_x_discrete(limits = variants) +
        scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.1),
                           labels = scales::percent_format(accuracy = 1)) +
        scale_colour_manual(values=cbbPalette) + 
        geom_text(aes(label=sprintf("%0.3f", round(value, digits = 3))), 
                      position=position_dodge(width=0.9), 
                      vjust=-0.25) + 
        scale_fill_discrete(name = "Variants") +
        theme_set(theme_get() + theme(text = element_text(family = 'Open Sans'))) 

```

# Methods
## LoFreq filter
| LoFreq is used with default filter settings:       |                   |
|:---------------------------------------------------|:------------------|
| minimum coverage                                   | 10                |
| Strand-Bias Multiple Testing Correction, fdr corr. | pvalue > 0.001000 |
| Minimum SNV Quality (Phred)                        | 63                |
| Minimum Indel Quality (Phred)                      | 47                |

## VEP settings  
* Species: SARS-CoV-2  
* Assembly: ASM985889v3  

|                                                   |        |
|:--------------------------------------------------|:-------|
| Matched Annotations from NCBI and EMBL-EBI (MANE) | yes    |
| Restrict results by severity of consequence       | no     |
| upstream/downstream distance                      | 5000bp |


# Raw data 

```{r, include = F}
snvs <- readLines(params$snv_file) %>% paste0(collapse="\n") %>% base64_urlencode()
```
Called SNVs:  
[Download SNVs.csv](`r sprintf('data:text/csv;base64,%s', snvs)`)
```{r, include = F}
# can possible be fused together with above. But rigth now it's safer like this. 
# write.csv2(vepfile.df, "./file.csv") # not sure about the funct of the dataframe here, but it works so I leave it for now
vep <- readLines(params$vep_file) %>% paste0(collapse="\n") %>% base64_urlencode()
```
Variant effect prediction (*Ensemble VEP output*):  
[Download VEP_out.csv](`r sprintf('data:text/csv;base64,%s', vep)`)

```{r csv_output_variant_plot, include = F, eval = executeDeconvolution}
# get all possible variants
all_variants <- colnames (msig_all)
output_variants <- file.path(csv_output_dir, "data_variant_plot.csv")

if (file.exists (output_variants)) {
    output_variant_plot <- read.table (output_variants, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_variant_plot <- data.frame (samplename = character(), # brauche ich als input von sample sheet 
                                       dates = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (variant in all_variants) {
      output_variant_plot[,variant] <- numeric()
    }
    
  #write header line
  write.table(t(colnames(output_variant_plot)), output_variants, sep = "\t", 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
}
# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_variant_plot <- bind_rows(output_variant_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_variant_plot$samplename))

# write deconv values to df
for (i in all_variants){
  if (i %in% df$name){
    # check if variant already has a column
    if (i %in% colnames(output_variant_plot)) {
        output_variant_plot[sample_row,][i] <- df$value[df$name == i]
}
  }
}
write.table(output_variant_plot[sample_row,], output_variants, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
```{r csv_output_mutation_plot, message = FALSE, warning = FALSE, include = FALSE}
match.df <- unique(match.df)
  
# get all possible mutations
all_mutations <- sigmuts_deduped$value
output_mutations <- file.path(csv_output_dir, "data_mutation_plot.csv")


if (file.exists (output_mutations)) {
    output_mutation_plot <- read.table (output_mutations, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_mutation_plot <- data.frame (samplename = character(), # brauche ich als input von sample sheet 
                                       dates = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (mutation in all_mutations) {
      output_mutation_plot[,mutation] <- numeric()
    }
    #write header line
    write.table(t(colnames(output_mutation_plot)), output_mutations, sep = "\t", 
                  row.names = FALSE, col.names = FALSE, quote = FALSE)
}

# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_mutation_plot <- bind_rows(output_mutation_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_mutation_plot$samplename))

# write mutation frequency values to df
for (i in all_mutations){
  if (i %in% match.df$AA_mut){
    # check if variant already has a column
    if (i %in% colnames(output_mutation_plot)) {
        output_mutation_plot[sample_row,][i] <- match.df$freq[match.df$AA_mut == i]
}
  }
}
write.table(output_mutation_plot[sample_row,], output_mutations, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
