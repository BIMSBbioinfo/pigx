---
title: "SARS-CoV-2 variant report"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params:
    @PARAMS_SAMPLE_NAME@

---

Read config.yml for the locations of sample sheet, pipeline output and sigmut loc and variants_dir
```{r, child="_settings.Rmd"}
```
# Input Settings
```{r printInputSettings, echo = FALSE}
sample_name <- params$sample_name
location_sigmuts <- sigmut_db

vepfile <- file.path(variants_dir, paste0(sample_name, "_vep_sarscov2_parsed.txt"))
snvfile <- file.path(variants_dir, paste0(sample_name, "_snv.csv"))
sampledir <- variants_dir

# TODO: @Jan @Miri pls add those input values
# all variables should be strings 
# if nothing is given, the default should be NA
# I filled in testing placeholder for now
csv_output_dir <- var_timecourse_csv
sample_sheet <- data.table::fread(sample_sheet) #read in sample file and then get the rest:
date <- "21/03/25"
time <- "22:00:00 - 21:00:00"
location_name <- "BER" 
coordinates_lat <- "52.3646054650197"
coordinates_long <- "13.5098643274129"

``` 
### Sample: `r sample_name` 

```{r test_files, include = FALSE}
# location_sigmuts <- 'tests/databases/sigmut_db'
# sampledir <- 'tests'
# # vepfile <- '/mnt/beast/pathogenomics/pigx_sarscov2_ww/output/vep/Test_vep_sarscov2_reportinput.txt' 
# vepfile <- 'tests/sample_data/Test_vep_sarscov2_parsed.txt' 
# snvfile <- 'tests/sample_data/Test_snv.csv'
```
This report shows the variant analysis of SARS-CoV-2 RNA-seq samples from wastewater samples. Variants are 
identified by SNV calling. Translated protein mutations were matched against lists of signature mutations for known
variants of concern (VOC) as found on [outbreak.info](https://outbreak.info/situation-reports) and [CoVariant.org](https://covariants.org/variants/S.501Y.V1).

```{r function_parse_snv_csv, include = FALSE, warning = F, message = F}
parse_snv_csv <- function (snvfile,...){ # allele frequency from v-pipe vcf
  #' input: csv file derived from vpipe vcf when using LoFreq,
  #' parsing snv-csv file for coverage, frequency and genomic mutation information
  
  snvtable <- read.table(snvfile, sep = ',', header = T)
  freq <- snvtable$AF
  cov <- snvtable$DP
  Ref <- snvtable$Ref
  Pos <- snvtable$Pos
  Var <- snvtable$Var
  snvinfo.df <- data.frame(Ref = Ref,
                        Pos = Pos, 
                        Var = Var,
                        gene_mut = paste0(Ref, Pos, Var),
                        stringsAsFactors = FALSE)
  snv.info <- cbind(gene_pos=snvinfo.df[,"Pos"], gene_mut=snvinfo.df[,"gene_mut"],freq,cov)
  
  return(snv.info)
}

get_protein_mut <- function (vepfile){ # parse together from vep output "Protein_position" and "Amino_acid"
  
  # reading in whole vep txt output
    vepfile.df <- read.table(vepfile, sep = ',', header = T) # you should include in the vep script to parse out the # 
      #in the beginning of the line or include that step here. 
    
    # parsing snv and protmut location
    locations <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
                            prot_mut_loc = vepfile.df$Protein_position, 
                            AAs = str_split_fixed(vepfile.df$Amino_acids, "/",2), 
                            Conseq = vepfile.df$Consequence,
                            genes = vepfile.df$SYMBOL)
    locations <- dplyr::na_if(locations,'')
    
    # delete all rows with no protein position value
    locations <- locations %>% filter(!grepl("^-", prot_mut_loc))
    # specific B117 mutations: 21990-21993, 21764-21770, maybe also 3675-3677, 69-70 - all there
    
    
    detectable_deletions <- function (x, colnames) { 
      
      if (x['gene_mut_loc.2'] != x['gene_mut_loc.3'] & str_detect(x['prot_mut_loc'],"-")){
      
        constant_before <- as.data.frame((cbind(x['gene_mut_loc.1'], x['gene_mut_loc.2'], x['gene_mut_loc.3'])))
        constant_after <- as.data.frame((cbind(x['Conseq'],x['genes'])))
      
        split_prot_pos <- str_split(x['prot_mut_loc'],"-")
        list_prot_pos <- list()
        for (i in 1:length(split_prot_pos)){
          list_prot_pos[[i]] <- seq(as.numeric(split_prot_pos[[i]][1]),as.numeric(split_prot_pos[[i]][2]))
        }
        
        extendet <- as.data.frame(qpcR:::cbind.na(as.character(unlist(list_prot_pos)), as.character(unlist(str_split(x['AAs.1'],''))), as.character(str_split(x['AAs.2'],''))))
        extendet[is.na(extendet)] <- '-' 
        
        full <- as.data.frame(cbind(constant_before,extendet, constant_after))
        colnames(full) <- colnames
        full$prot_mut_loc <- vapply(full$prot_mut_loc, paste, collapse = " ", character(1L))
        full$AAs.1 <- vapply(full$AAs.1, paste, collapse = " ", character(1L))
        full$AAs.2 <- vapply(full$AAs.2, paste, collapse = " ", character(1L))
        
        return(full)
      }
      
    }
    deletions.df <- locations
    deletions.df <- locations %>%
                        filter(gene_mut_loc.2 != gene_mut_loc.3 &
                                Conseq == "inframe_deletion" &
                                str_detect(deletions.df$prot_mut_loc,"-"))
    colnames <- colnames(deletions.df)
    
    # if there is a deletion the snv would span a couple of positions, if there is not such a spanning region there are no deletions
    # ! 06/05/2021 Vic - I think, I don't know how robust this is, but it will work for the sig mutations we have so far
    if (!(any(is.na(locations[,'gene_mut_loc.3'])))) {
        deletions <- dplyr::bind_rows(apply(deletions.df,1, detectable_deletions, colnames = colnames))
        locations <- dplyr::bind_rows(locations,deletions)
    }
  
  # substitute "nothing" at alternative-aa-column (for deletions) with "-"
  locations$AAs.2[is.na(locations$AAs.2)] <- "-"
  # clean - characters 
  locations$AA_mut <- paste(locations$AAs.1,locations$prot_mut_loc,locations$AAs.2, sep = "")
  # adding gene information
  
  
  return(locations)
}

deconv <- function (bulk,sig){
  
  rlm_model = suppressWarnings(MASS::rlm(sig,bulk, maxit = 100))
      
      
  rlm_coefficients = rlm_model$coefficients
  
  rlm_coefficients = ifelse(rlm_coefficients < 0, 0, rlm_coefficients)
  
  sumOfCof = sum(rlm_coefficients)
  
  rlm_coefficients = rlm_coefficients / sumOfCof  #normalize so coefficients add to 1
  
  as.vector(rlm_coefficients)
}

dedupe <- function (df) {
    transposed <- t (df)
    dupes <- duplicated (transposed, fromLast=TRUE)
    allDupes <- dupes | duplicated (transposed, fromLast=FALSE)
    if (any (allDupes)) {
        grouped <- colnames (df)[allDupes]
        groupName <- paste(grouped, collapse = ",")
        deduped <- df[!dupes]
        names (deduped)[names (deduped) %in% grouped] <- groupName
        return (deduped)
    } else {
        return (df)
    }
}

dedupeMuts <- function (mut, sigmut.df, dedup.df) {
        # get variant group per mutation
        duped_muts <- grep (mut, sigmut.df$value)
        grouped <- sigmut.df$name[duped_muts]
        groupName <- paste(grouped, collapse = ",")
      
        dedup.df$name[dedup.df$value == mut] <- groupName
        return (dedup.df)
}  
```

```{r development_parsing_deletions_properly, warning = F, include = FALSE}
# library(stringr)
# library(dplyr)
# library(tidyr)
# library(qpcR)
# 
# #vepfile <- '/mnt/beast/pathogenomics/vpipe/akalinlab_pathogenomics/vep_mutation_matching/210417_VEP_results/vep_sarscov2_WW_S26.txt'
# 
# vepfile.df <- read.table(vepfile, sep = '\t', header = T) # you should include in the vep script to parse out the # 
#   #in the beginning of the line or include that step here. 
# 
# # parsing snv and protmut location
# locations <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
#                         prot_mut_loc = vepfile.df$Protein_position, 
#                         AAs = str_split_fixed(vepfile.df$Amino_acids, "/",2), 
#                         Conseq = vepfile.df$Consequence)
# locations <- dplyr::na_if(locations,'')
# 
# # delete all rows with no protein position value
# locations <- locations %>% filter(!grepl("^-", prot_mut_loc))
# # specific B117 mutations: 21990-21993, 21764-21770, maybe also 3675-3677, 69-70 - all there
# 
# detectable_deletions <- function (x, colnames) { 
#   
#   if (x['gene_mut_loc.2'] != x['gene_mut_loc.3'] & str_detect(x['prot_mut_loc'],"-")){
#   
#     constant_before <- as.data.frame((cbind(x['gene_mut_loc.1'], x['gene_mut_loc.2'], x['gene_mut_loc.3'])))
#     constant_after <- as.data.frame((x['Conseq']))
#   
#     split_prot_pos <- str_split(x['prot_mut_loc'],"-")
#     list_prot_pos <- list()
#     for (i in 1:length(split_prot_pos)){
#       list_prot_pos[[i]] <- seq(as.numeric(split_prot_pos[[i]][1]),as.numeric(split_prot_pos[[i]][2]))
#     }
#     
#     extendet <- as.data.frame(qpcR:::cbind.na(as.character(unlist(list_prot_pos)), as.character(unlist(str_split(x['AAs.1'],''))), as.character(str_split(x['AAs.2'],''))))
#     extendet[is.na(extendet)] <- '-' 
#     
#     full <- as.data.frame(cbind(constant_before,extendet, constant_after))
#     colnames(full) <- colnames
#     full$prot_mut_loc <- vapply(full$prot_mut_loc, paste, collapse = " ", character(1L))
#     full$AAs.1 <- vapply(full$AAs.1, paste, collapse = " ", character(1L))
#     full$AAs.2 <- vapply(full$AAs.2, paste, collapse = " ", character(1L))
#     
#     return(full)
#   }
#   
# }
# deletions.df <- locations
# deletions.df <- locations %>%
#                     filter(gene_mut_loc.2 != gene_mut_loc.3 &
#                             Conseq == "inframe_deletion" &
#                             str_detect(deletions.df$prot_mut_loc,"-"))
# colnames <- colnames(deletions.df)
# deletions <- dplyr::bind_rows(apply(deletions.df,1, detectable_deletions, colnames = colnames))
# locations <- dplyr::bind_rows(locations,deletions)
```


```{r process_signature_mutations, message=F, warning=F, include = FALSE}
# reading in signature data
# it's probably not really necessary to add the pase0 column but I like to have a full overview
# but maybe this part could be done a bt nicer more compact with e.g. looping through the file directories?
################
b117 <- read.table(file.path(location_sigmuts,"B117_outbreakinfo_mutation_report_data_2021-03-06.tsv"),
                sep="\t",header=T)
# modifiyng deletions, subsitute "nothing" with a - e.g: D789 -> D789-
b117$alt_aa <- na_if(b117$alt_aa, '')
b117$alt_aa[is.na(b117$alt_aa)] <- "-"
#pasting column with correct prot mutation notation
b117$AA_mut <- paste0(b117$ref_aa, b117$codon_num, b117$alt_aa)
#####################
b1351 <- read.table(file.path(location_sigmuts,"B1351_outbreakinfo_mutation_report_data_2021-03-06.tsv"),
                sep="\t",header=T)
b1351$alt_aa <- na_if(b1351$alt_aa, '')
b1351$alt_aa[is.na(b1351$alt_aa)] <- "-"
b1351$AA_mut <- paste0(b1351$ref_aa, b1351$codon_num, b1351$alt_aa)
b1427 <- read.table(file.path(location_sigmuts,"B1427_outbreakinfo_mutation_report_data_2021-03-06.tsv"),
                sep="\t",header=T)
b1427$alt_aa <- na_if(b1427$alt_aa, '')
b1427$alt_aa[is.na(b1427$alt_aa)] <- "-"
b1427$AA_mut <- paste0(b1427$ref_aa, b1427$codon_num, b1427$alt_aa)
b1429 <- read.table(file.path(location_sigmuts,"B1429_outbreakinfo_mutation_report_data_2021-03-06.tsv"),
                sep="\t",header=T)
b1429$alt_aa <- na_if(b1429$alt_aa, '')
b1429$alt_aa[is.na(b1429$alt_aa)] <- "-"
b1429$AA_mut <- paste0(b1429$ref_aa, b1429$codon_num, b1429$alt_aa)
b1526 <- read.table(file.path(location_sigmuts,"B1526_outbreakinfo_mutation_report_data_2021-03-06.tsv"),
                sep="\t",header=T)
b1526$alt_aa <- na_if(b1526$alt_aa, '')
b1526$alt_aa[is.na(b1526$alt_aa)] <- "-"
b1526$AA_mut <- paste0(b1526$ref_aa, b1526$codon_num, b1526$alt_aa)
p1 <- read.table(file.path(location_sigmuts,"P1_outbreakinfo_mutation_report_data_2021-03-06.tsv"),
                sep="\t",header=T)
p1$alt_aa <- na_if(p1$alt_aa, '')
p1$alt_aa[is.na(p1$alt_aa)] <- "-"
p1$AA_mut <- paste0(p1$ref_aa, p1$codon_num, p1$alt_aa)
################
vepfile.df <- read.table(vepfile,sep = ",", header = T) #TODO - in na's umwandeln
vepfile.df <- na_if(vepfile.df, "-")
sig_mutations.df <- as.data.frame(qpcR:::cbind.na(b117=b117$AA_mut, b1351=b1351$AA_mut,
                                                  b1427=b1427$AA_mut, b1429=b1429$AA_mut,
                                                  b1526=b1526$AA_mut, p1=p1$AA_mut))
sig_mutations.df <- sig_mutations.df %>%
                          tidyr::pivot_longer(everything()) %>%
                            tidyr::drop_na(.,value)

# deduplicate dataframe
# fixme: I was not sure, how I can include this in my function but should be possible, will come back to it later
dupes <- duplicated (sig_mutations.df$value, fromLast=TRUE)
allDupes <- dupes | duplicated (sig_mutations.df$value, fromLast=FALSE)

if (any (allDupes)) {
    sigmuts_deduped <- sig_mutations.df[!dupes,]
}

# fixme: I think this should be done with some apply() function? 
for (mut in sig_mutations.df$value) {
  sigmuts_deduped <- dedupeMuts(mut, sig_mutations.df, sigmuts_deduped)
}

```

```{r match_snvs_to_signature_mutations, message=F, warning=F, include = FALSE}
variant_protein_mut <- get_protein_mut(vepfile)
variant_protein_mut <- dplyr::left_join(variant_protein_mut, sigmuts_deduped, by = c('AA_mut'='value'))
match.df <- variant_protein_mut %>%
                    filter(!is.na(name))
nomatch.df <- variant_protein_mut %>%
                        filter(is.na(name))
```

```{r, message=F, warning=F, include = FALSE}
# Data frame to use for the tables
lofreq.info <- as_data_frame(parse_snv_csv(snvfile))
# vep.info <- write the part that returns the variant_protein_mut into a function 
vep.info <- variant_protein_mut
# add freqency and coverage information to protein mutations
#variant_protein_mut <- dplyr::left_join(variant_protein_mut, sig_mutations.df, by = c('AA_mut'='value'))
complete.df <- dplyr::left_join(lofreq.info, vep.info, by = c('gene_pos'='gene_mut_loc.2'), copy = T)
match.df <- complete.df %>%
                    filter(!is.na(name))
nomatch.df <- complete.df %>%
                        filter(is.na(name))
```
## Mutations matching variants of concern

The following tables list the called SNVs found by [*LoFreq*](https://csb5.github.io/lofreq/) and translated 
to protein mutations by [*Ensemble VEP*](https://covid-19.ensembl.org/info/docs/tools/vep/index.html). Table 1 shows 
the mutations matching signature mutations for given SARS-CoV-2 variants. 
Table 2 shows all other mutations without any match. 

```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 1: SNVs from sample matching signature mutations")
```
```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
SignatureTable <-  data.frame("SNV" = match.df$gene_mut, 
                  "gene" = match.df$genes,
                  "protein_mutation" = match.df$AA_mut,
                  "variant" = match.df$name, # maybe more nice writing of it e.g B1.1.7            
                  "frequency" = match.df$freq, # maybe more clear name stating which frequency
                  "coverage" =  match.df$cov) # maybe more clear title stating which coverage 
DT::datatable(SignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 180,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```
```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 2: SNVs from sample not matching any signature mutations")
```
```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
NoSignatureTable <-  data.frame("SNV" = nomatch.df$gene_mut, 
                  "gene" = nomatch.df$genes,
                  "protein_mutation" = nomatch.df$AA_mut,
                  "frequency" = nomatch.df$freq, # maybe more clear name stating which frequency
                  "coverage" =  nomatch.df$cov) # maybe more clear title stating which coverage
DT::datatable(NoSignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 400,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```
# Deconvolution

```{r getting_unique_muts_bulk, message=F, warning=F, include = FALSE}

# get prot.mutations only 
muts <- c(match.df$AA_mut)
# get bulk frequency values
bulk <- as.numeric(match.df$freq)

```


```{r creating_signature_matrix_simple, message=F, warning=F, include = FALSE}
# create an empty data frame add a column for the Wildtype
msig <- data.frame(muts,WT=0,b117=0,b1351=0,b1427=0,b1429=0,b1526=0,p1=0)

# make sigmuts per variant tables new with parsed mutations
msig[msig$muts %in% b117$AA_mut,"b117"]=1
msig[msig$muts %in% b1351$AA_mut,"b1351"]=1
msig[msig$muts %in% b1351$AA_mut,"b1427"]=1
msig[msig$muts %in% b1351$AA_mut,"b1429"]=1
msig[msig$muts %in% b1351$AA_mut,"b1526"]=1
msig[msig$muts %in% p1$AA_mut,"p1"]=1
msig[1,2] <- 0 # put the WT signature, here it's 0 and not 1 bc it will be inversed in the next step
```
```{r adding_wt_to_sigmat, message=F, warning=F, include = FALSE}

# making the WT rows

# 1. make "WT mutations" 
muts_wt <- lapply(muts,function(x) str_replace(x,regex(".$"), str_sub(x, 1,1)))
muts_wt.df <- data.frame(muts = unlist(muts_wt))
# 2. make frequency values, subtract the observed freqs for the real mutations from 1
bulk_wt <- lapply(bulk, function (x) {1-x})

# 3. make matrix with wt mutations and inverse the values and wild type freqs
msig_inverse <- bind_cols(muts_wt.df, as.data.frame(+(!msig[,-1])))

# fixme: not sure if this really is a nice way to concat those things...
muts_all <- c(muts_wt,muts)
muts_all.df <- data.frame(muts = unlist(muts_all))

bulk_all <- c(bulk_wt, bulk)
bulk_all.df <- data.frame(freq = unlist(bulk_all))

msig_all <- rbind(msig_inverse[,-1],msig[,-1])

# 4. concat the data frames

# without bulk freq for building the signature matrix
msig_stable <- bind_cols(muts_all.df,msig_all)

# with bulk freq for export and overview
msig_stable_complete <- bind_cols(muts_all.df,msig_all,bulk_all.df)
```


```{r collapse_identicals, message=F, warning=F, include = FALSE}
# When multiple columns look like the same, the deconvolution will not work, because the function can't distinguish 
# between those columns. The workaround for now is to identify those equal columns and merge them into one, returning also
# a vector with the information about which of the columns were merged. 

msig_stable_unique <- dedupe(msig_stable)

```
```{r deconvolution, message=F, warning=F, include = FALSE}

sig <- msig_stable_unique[,-1]
variant_abundance <- deconv(as.numeric(bulk_all),sig)

```

```{r plot, message=F, warning=F, echo = FALSE}

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# work in progress...only to show how it theoretically can look like in the report
variants <- colnames(msig_stable_unique[,-1])
df <- data.frame(rbind(variant_abundance))
colnames(df) <- variants
df <- df %>% 
    tidyr::pivot_longer(everything())

 ggplot(data = df, aes(name,value, 
                       fill = name)) +
        geom_bar(stat="identity") +
        labs(title = "Proportion of variants of concern inferred from deconvolution",
             x = "Variants",
             y = "Percentage") +
        scale_x_discrete(limits = variants) +
        scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.1)) +
        scale_colour_manual(values=cbbPalette) + 
        geom_text(aes(label=sprintf("%0.3f", round(value, digits = 3))), 
                      position=position_dodge(width=0.9), 
                      vjust=-0.25) + 
        scale_fill_discrete(name = "Variants")

```

## Methods
### LoFreq filter
|LoFreq is used with default filter settings: |  |  
|:--------------------------------------------|:-|
|minimum coverage| 10|    
|Strand-Bias Multiple Testing Correction, fdr corr.| pvalue > 0.001000|    
|Minimum SNV Quality (Phred)|63|  
|Minimum Indel Quality (Phred)|47|

### VEP settings  
* Species: SARS-CoV-2  
* Assembly: ASM985889v3  

|  |  |  
|:-|:-|  
|Matched Annotations from NCBI and EMBL-EBI (MANE)| yes |
|Restrict results by severity of consequence | no |  
|upstream/downstream distance | 5000bp|  

## Deconvolution 
Deconvolution is done by using robust regression. The resulting coefficients are normalized to get the percentage of
each present variant.

## Raw data 

```{r, include = F}
# write.csv2(mtcars, "./file.csv") # not sure about the funct of the dataframe here, but it works so I leave it for now
library(magrittr)
readLines(snvfile) %>% 
  paste0(collapse="\n") %>% 
  openssl::base64_encode() -> snvs
```
Called SNVs:  
[Download SNVs.csv](`r sprintf('data:text/csv;base64,%s', snvs)`)
```{r, include = F}
# can possible be fused together with above. But rigth now it's safer like this. 
# write.csv2(vepfile.df, "./file.csv") # not sure about the funct of the dataframe here, but it works so I leave it for now
readLines(vepfile) %>% 
  paste0(collapse="\n") %>% 
  openssl::base64_encode() -> vep
```
Variant effect prediction (*Ensemble VEP output*):  
[Download VEP_out.csv](`r sprintf('data:text/csv;base64,%s', vep)`)

```{r csv_output_variant_plot, include = F}
# get all possible variants
all_variants <- colnames (msig_all)
output_variants <- file.path(csv_output_dir,"data_variant_plot.csv")

if (file.exists (output_variants)) {
    output_variant_plot <- read.table (output_variants, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_variant_plot <- data.frame (samplename = character(), # brauche ich als input von sample sheet 
                                       dates = character(),
                                       time = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (variant in all_variants) {
      output_variant_plot[,variant] <- numeric()
    }
    
  #write header line
  write.table(t(colnames(output_variant_plot)), output_variants, sep = "\t", 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
}
# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                time = time,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_variant_plot <- bind_rows(output_variant_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_variant_plot$samplename))

# write deconv values to df
for (i in all_variants){
  if (i %in% df$name){
    # check if variant already has a column
    if (i %in% colnames(output_variant_plot)) {
        output_variant_plot[sample_row,][i] <- df$value[df$name == i]
}
  }
}
write.table(output_variant_plot[sample_row,], output_variants, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```