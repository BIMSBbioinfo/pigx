---
title: "SARS-CoV-2 Mutations and Variant report"
nav: "Variant report"
author: "BIMSB Bioinformatics Platform"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params:
  sample_name: ''
  sigmut_db: ''
  variants_dir: ''
  vep_file: ''
  snv_file: ''
  sample_sheet: ''
  logo: ''
---

<div id="logo" align="top">
`r knitr::include_graphics(params$logo)`
</div>

<sample>`r params$sample_name`</sample>

```{r libs, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(knitr)
library(dplyr)
library(ggplot2)
library(DT)
library(tidyr)
library(qpcR)
library(stringr)
library(magrittr)
library(base64url)
```

```{r printInputSettings, echo = FALSE}
sample_name <- params$sample_name
sample_sheet <- data.table::fread(params$sample_sheet)
location_sigmuts <- params$sigmut_db

csv_output_dir <- params$variants_dir
date <- as.character(sample_sheet[name==sample_name]$date)
location_name <- as.character(sample_sheet[name==sample_name]$location_name)
coordinates_lat <- as.character(sample_sheet[name==sample_name]$coordinates_lat)
coordinates_long <- as.character(sample_sheet[name==sample_name]$coordinates_long)

``` 

This report shows the variant analysis of SARS-CoV-2 from wastewater samples. Mutations are 
identified by single-nucleotide-variant (SNV) calling performed by [LoFreq](https://csb5.github.io/lofreq/). 
Translated to amino acid mutations by using [Ensemble VEP - COVID-19](https://covid-19.ensembl.org/info/docs/tools/vep/index.html).
The list of found mutations (including synonymous and non-synonymous mutations) were matched against lists of 
signature mutations characterising variants of concern (VOC) of SARS-CoV-2 provided by [outbreak.info](https://outbreak.info/situation-reports) 
and [CoVariant.org](https://covariants.org/variants/S.501Y.V1).

```{r function_parse_snv_csv, include = FALSE, warning = F, message = F}
parse_snv_csv <- function (snvfile,...){ # allele frequency from v-pipe vcf
  #' input: csv file derived from vpipe vcf when using LoFreq,
  #' parsing snv-csv file for coverage, frequency and genomic mutation information
  
  snvtable <- read.table(snvfile, sep = ',', header = T)
  freq <- snvtable$AF
  cov <- snvtable$DP
  Ref <- snvtable$Ref
  Pos <- snvtable$Pos
  Var <- snvtable$Var
  
  # concat position value and nucleotides to nucleotide-mutation-notation 
  snvinfo.df <- data.frame(Ref = Ref,
                        Pos = Pos, 
                        Var = Var,
                        gene_mut = paste0(Ref, Pos, Var),
                        stringsAsFactors = FALSE)
  # concat nucleotide-mutation-notation with mutation frequencies and coverage
  # seperate posistion column will be used for joining data frames
  snv.info <- cbind(gene_pos=snvinfo.df[,"Pos"], gene_mut=snvinfo.df[,"gene_mut"],freq,cov)
  
  return(snv.info)
}

detectable_deletions <- function (x, colnames) { 
  #' deletions can span a range of position values indicated by a dash in the prot_mut_loc column.
  #' In those cases those ranges have to be split up in order to be able to detect single positions. This function should
  #' be used on a already filtered set of deletions derived from the vep-output. They are then split up and expanded with the 
  #' number of rows realted to the number of position. The function returns those extended lines as a dataframe which structure
  #' is matching the df structure which is returned by "get_protein_mut" 
  
  # check that the mutations spans multiple nucleotides AND multiple Amino Acids
  if (x['gene_mut_loc.2'] != x['gene_mut_loc.3'] & str_detect(x['prot_mut_loc'],"-")){
  
    # extract columns from input dataframe where the content of the rows won't change, but where rows will be duplicated 
    # when merging back with the extended deletion rows
    constant_before <- as.data.frame((cbind(x['gene_mut_loc.1'], x['gene_mut_loc.2'], x['gene_mut_loc.3'])))
    constant_after <- as.data.frame((cbind(x['Conseq'],x['genes'])))
  
    # split the position values denoting a range and make as many new rows as positions spanned with the missing 
    # position values e.g: 1-3 (1 row) will become 1,2,3 (3 rows)
    split_prot_pos <- str_split(x['prot_mut_loc'],"-")
    list_prot_pos <- list()
    for (i in 1:length(split_prot_pos)){
      list_prot_pos[[i]] <- seq(as.numeric(split_prot_pos[[i]][1]),as.numeric(split_prot_pos[[i]][2]))
    }
    
    # TODO instead of qpcR bind_cols from dplyer
    # split groups of reference Amino acids (AAs.1) if necessary, concat the extendet columns
    extendet <- as.data.frame(qpcR:::cbind.na(as.character(unlist(list_prot_pos)), as.character(unlist(str_split(x['AAs.1'],''))), as.character(str_split(x['AAs.2'],''))))
    # the dash is the sign for an Amino Acid that was deleted
    extendet[is.na(extendet)] <- '-' 
    
    # join the columns with the extended rows back with the rest of the original dataframe
    full <- as.data.frame(cbind(constant_before,extendet, constant_after))
    colnames(full) <- colnames
    # match the extended rows with added positions values to the Amino acids. If a group of reference Amino acids in AAs.1
    # is given it's splitted and matched according to their order. The mutation in AAs.2 is only applied to the last position
    # every other position get's an dash in column AAs.2
    # e.g.: 1-3 is exended to seperate rows, if htere was ABC in AAs.1 and C in AAs.2, the results would be A1-, B2-, C3C
    full$prot_mut_loc <- vapply(full$prot_mut_loc, paste, collapse = " ", character(1L))
    full$AAs.1 <- vapply(full$AAs.1, paste, collapse = " ", character(1L))
    full$AAs.2 <- vapply(full$AAs.2, paste, collapse = " ", character(1L))
    
    return(full)
  }
  
}

get_protein_mut <- function (vepfile){ # parse together from vep output "Protein_position" and "Amino_acid"
  #' input: []_sarscov2_parsed.txt, parsed vcf from VEP CLI, comma seperated
  #' this function is for parsing the information about mutation position in the amino acid sequence, the reference aa and
  #' the alternative mutation into the aa-mutation-notation which is later on comparable to the lists of signature mutations
  
  # reading in whole vep txt output
    vepfile.df <- read.table(vepfile, sep = ',', header = T) # you should include in the vep script to parse out the # 
      #in the beginning of the line or include that step here. 
    
    # parsing snv and protmut location
    # parsing gene mutation
    gene_mutation <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
                                nucleotides = str_split_fixed(
                                                str_split_fixed(vepfile.df$Uploaded_variation, 
                                                                "[_-]+", n=4) [,4], "/", n=2))
    gene_mutation$gene_mut <- paste0(gene_mutation$nucleotides.1, gene_mutation$gene_mut_loc.2, gene_mutation$nucleotides.2)
                                                                   
    locations <- data.frame(gene_mut_loc = str_split_fixed(vepfile.df$Location,"[:-]+", n=3),
                            gene_mut = gene_mutation$gene_mut,
                            prot_mut_loc = vepfile.df$Protein_position, 
                            AAs = str_split_fixed(vepfile.df$Amino_acids, "/",2), 
                            Conseq = vepfile.df$Consequence,
                            genes = vepfile.df$SYMBOL)
    locations <- dplyr::na_if(locations,'')
    
    # delete all rows with no protein position value
    locations <- distinct(locations %>% filter(!grepl("^-", prot_mut_loc)))
    # specific B117 mutations: 21990-21993, 21764-21770, maybe also 3675-3677, 69-70 - all there
  
    deletions.df <- locations
    deletions.df <- locations %>%
                        filter(gene_mut_loc.2 != gene_mut_loc.3 &
                                Conseq == "inframe_deletion" &
                                str_detect(deletions.df$prot_mut_loc,"-"))
    colnames <- colnames(deletions.df)
    
    # if there is a deletion the snv would span a couple of positions, if there is not such a spanning region there are no deletions
    # ! 06/05/2021 Vic - I think, I don't know how robust this is, but it will work for the sig mutations we have so far
    if (!(any(is.na(locations[,'gene_mut_loc.3'])))) {
        deletions <- dplyr::bind_rows(apply(deletions.df,1, detectable_deletions, colnames = colnames))
        locations <- dplyr::bind_rows(locations,deletions)
    }
  
  # substitute "nothing" at alternative-aa-column (for deletions) with "-"
  locations$AAs.2[is.na(locations$AAs.2)] <- "-"
  # clean - characters 
  locations$AA_mut <- paste(locations$AAs.1,locations$prot_mut_loc,locations$AAs.2, sep = "")
  # adding gene information
  
  
  return(locations)
}

deconv <- function (bulk,sig){
  #' This function performs the deconvolution using a signature matrix for the mutations found in the sample 
  #' and bulk frequency values derived by the SNV caller
  #' it was build by Altuna
  
  rlm_model = suppressWarnings(MASS::rlm(sig,bulk, maxit = 100))
      
      
  rlm_coefficients = rlm_model$coefficients
  
  rlm_coefficients = ifelse(rlm_coefficients < 0, 0, rlm_coefficients)
  
  sumOfCof = sum(rlm_coefficients)
  
  rlm_coefficients = rlm_coefficients / sumOfCof  #normalize so coefficients add to 1
  
  as.vector(rlm_coefficients)
}

# TODO this does not lead to 100% correct results and has to be updated with "dedupeVariants" from PR 48
dedupe <- function (df) {
    transposed <- t (df)
    dupes <- duplicated (transposed, fromLast=TRUE)
    allDupes <- dupes | duplicated (transposed, fromLast=FALSE)
    if (any (allDupes)) {
        grouped <- colnames (df)[allDupes]
        groupName <- paste(grouped, collapse = ",")
        deduped <- df[!dupes]
        names (deduped)[names (deduped) %in% grouped] <- groupName
        return (deduped)
    } else {
        return (df)
    }
}

dedupeMuts <- function (mut, sigmut.df, dedup.df) {
        #' this function is a different version of "dedupe" 
        #' if a signature mutation is shared by multiple variants the mutation-tables
        #' would have seperate rows for the same mutation. This function is for concatenating all the variants 
        #' that share that mutation. It requires the original df with all mutations, the deduplicated one 
        #' (only one row per mutation) and the mutation for which this procedure should be applied
        #' This function is not yet completely refined and should be improved further
        # get variant group per mutation
        duped_muts <- grep (mut, sigmut.df$value)
        grouped <- sigmut.df$name[duped_muts]
        groupName <- paste(grouped, collapse = ",")
      
        dedup.df$name[dedup.df$value == mut] <- groupName
        return (dedup.df)
}  
```

```{r process_signature_mutations, message=F, warning=F, include = FALSE}

# Read signature data
# TODO: these should probably all be declared inputs.
sigmuts <- list(list(file="B117_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b117"),
                list(file="B1351_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1351"),
                list(file="B1427_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1427"),
                list(file="B1429_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1429"),
                list(file="B1526_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="b1526"),
                list(file="P1_outbreakinfo_mutation_report_data_2021-03-06.tsv",
                     name="p1"),
                list(file="B16172_outbreakinfo_mutation_report_data_2021-05-26.tsv",
                     name="b16172"))

read_sigmuts <- function (sigmut) {
    file <- sigmut$file

    data <- read.table(file.path(location_sigmuts, file),
                       sep = "\t", header = TRUE)
    # modify deletions, substitute "nothing" with a dash e.g: D789 -> D789-
    data$alt_aa <- na_if (data$alt_aa, "")
    data$alt_aa[is.na(data$alt_aa)] <- "-"

    # Paste column with correct prot mutation notation
    data$AA_mut <- paste0(data$ref_aa, data$codon_num, data$alt_aa)

    # Return a table mapping strain name to mutation
    data.frame(name = sigmut$name,
               value = data$AA_mut)
}

sig_mutations.df <- do.call(rbind, lapply(sigmuts, read_sigmuts))

vepfile.df <- read.table(params$vep_file, sep = ",", header = T) 

vepfile.df <- na_if(vepfile.df, "-")

# deduplicate dataframe
# reasoning see description of "dedupeMuts"
# fixme: I was not sure, how I can include this in my function but should be possible, will come back to it later
dupes <- duplicated (sig_mutations.df$value, fromLast=TRUE)
allDupes <- dupes | duplicated (sig_mutations.df$value, fromLast=FALSE)

if (any (allDupes)) {
    sigmuts_deduped <- sig_mutations.df[!dupes,]
}

# fixme: I think this should be done with some apply() function? 
for (mut in sig_mutations.df$value) {
  sigmuts_deduped <- dedupeMuts(mut, sig_mutations.df, sigmuts_deduped)
}

```

```{r match_snvs_to_signature_mutations, message=F, warning=F, include = FALSE}
variant_protein_mut <- get_protein_mut(params$vep_file)
# match the variant names according to the signature mutations, if there is no signature mutation no name will be given
variant_protein_mut <- dplyr::left_join(variant_protein_mut, sigmuts_deduped, by = c('AA_mut'='value'))

```

```{r merge_vep_with_lofreq_info, message=F, warning=F, include = FALSE}
# get the SNV frequency values and coverage information for the mutations from the LoFreq output
lofreq.info <- as_data_frame(parse_snv_csv(params$snv_file)) 
vep.info <- variant_protein_mut

complete.df <- dplyr::left_join(lofreq.info, vep.info, by = c('gene_mut'='gene_mut'), copy = T)
# one aa mutation can have different codon mutations reported with different freqs- those have to be summed up
complete.df <- complete.df %>%
  group_by(across(c(-freq,-gene_mut,AA_mut))) %>%
  summarise(freq = sum(as.numeric(freq)), gene_mut = paste(gene_mut, collapse = ",")) %>%
  ungroup()

# sorting in mutations that match variants of concerns
match.df <- complete.df %>%
                    filter(!is.na(name))
nomatch.df <- complete.df %>%
                        filter(is.na(name))
```

# Mutations matching variants of concern

The following tables list the called SNVs. Table 1 shows the mutations matching signature mutations for given SARS-CoV-2 
variants. Table 2 shows all other mutations without any match. The columns are described as follows:

1. **SNV** -- nucleotide mutation in the pattern of: reference base, position nucleotide sequence, mutation base 
2. annotated gene
3. translated amino acid (AA) mutation in the pattern of: reference AA, position AA sequence, mutation AA
    * a asterix `*` denotes a stop codon
    * a dash `-` denotes a deletion
4. variant of concern which is described by this mutation
5. reported allele frequency
6. read coverage of that particular mutation

```{r, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 1: SNVs from sample matching signature mutations")
```
```{r sig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
# Display the filtered signature mutations and the variants accordingly in scrollable tables

SignatureTable <-  data.frame("SNV" = match.df$gene_mut, 
                  "gene" = match.df$genes,
                  "protein_mutation" = match.df$AA_mut,
                  "variant" = match.df$name, # TODO: more nice writing of it e.g B1.1.7            
                  "frequency" = match.df$freq, # TODO: more clear name stating which frequency
                  "coverage" =  match.df$cov) # TODO: more clear title stating which coverage 
DT::datatable(SignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 180,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```
```{r nonsig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
cat("\n Table 2: SNVs from sample not matching any signature mutations")
```
```{r non_sig_table, message=F, warning=F, echo = FALSE, results = 'asis'}
# Display the filtered signature mutations and the variants accordingly in scrollable tables

NoSignatureTable <-  data.frame("SNV" = nomatch.df$gene_mut, 
                  "gene" = nomatch.df$genes,
                  "protein_mutation" = nomatch.df$AA_mut,
                  "frequency" = nomatch.df$freq, # TODO more clear name stating which frequency
                  "coverage" =  nomatch.df$cov) # TODO more clear title stating which coverage
DT::datatable(NoSignatureTable,
              extensions = c('FixedColumns', 'Scroller'),
              options = list(fixedColumns = TRUE, 
                         scrollY = 400,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip'),
              filter = "bottom")
```

# Deconvolution

Deconvolution is done by using robust regression. It relies on signature mutations of each variant. It aims 
to predict the individual contributions of the variants of concern to the observed mutation frequencies in the bulk 
wastewater sample.

```{r getting_unique_muts_bulk, message=F, warning=F, include = FALSE}

# get prot.mutations only, input for the signature matrix 
muts <- c(match.df$AA_mut)
# get bulk frequency values, will be input for the deconvolution function
bulk <- as.numeric(match.df$freq)

# only execute the deconvolution when at least one mutation was found
executeDeconvolution <- length(muts) > 0
```


```{r creating_signature_matrix_simple, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
# create an empty data frame add a column for the Wildtype
# Wildtype in this case means the reference version of SARS-Cov-2
msig <- data.frame(muts,WT=0,b117=0,b1351=0,b1427=0,b1429=0,b1526=0,p1=0, b16172=0)

# making a matrix with the signature mutations found in the sample
# make binary matrix matching the mutations to the mutation-list per variant to see how many characterising mutations
# where found by variant 

b117 <- filter(sig_mutations.df, name == "b117")$value
msig[msig$muts %in% b117,"b117"]=1

b1351 <- filter(sig_mutations.df, name == "b1351")$value
msig[msig$muts %in% b1351,"b1351"]=1

b1427 <- filter(sig_mutations.df, name == "b1427")$value
msig[msig$muts %in% b1427,"b1427"]=1

b1429 <- filter(sig_mutations.df, name == "b1429")$value
msig[msig$muts %in% b1429,"b1429"]=1

b1526 <- filter(sig_mutations.df, name == "b1526")$value
msig[msig$muts %in% b1526,"b1526"]=1

p1 <- filter(sig_mutations.df, name == "p1")$value
msig[msig$muts %in% p1,"p1"]=1

b16172 <- filter(sig_mutations.df, name == "b16172")$value
msig[msig$muts %in% b16172, "b16172"]=1

msig[1,2] <- 0 # put the WT signature, here it's 0 and not 1 bc it will be inversed in the next step
```
```{r adding_wt_to_sigmat, message=F, warning=F, include = FALSE, eval = executeDeconvolution}

# for the deconvolution to work we need the "wild type" frequencies too. The matrix from above got mirrored, 
# wild type mutations are simulated the following: e.g. T210I (mutation) -> T210T ("wild type")

# 1. make "WT mutations" 
muts_wt <- lapply(muts,function(x) str_replace(x,regex(".$"), str_sub(x, 1,1)))
muts_wt.df <- data.frame(muts = unlist(muts_wt))
# 2. make frequency values, subtract the observed freqs for the real mutations from 1
bulk_wt <- lapply(bulk, function (x) {1-x})

# 3. make matrix with wt mutations and inverse the values and wild type freqs
msig_inverse <- bind_cols(muts_wt.df, as.data.frame(+(!msig[,-1])))

# fixme: not sure if this really is a nice way to concat those things...
muts_all <- c(muts_wt,muts)
muts_all.df <- data.frame(muts = unlist(muts_all))

bulk_all <- c(bulk_wt, bulk)
bulk_all.df <- data.frame(freq = unlist(bulk_all))

msig_all <- rbind(msig_inverse[,-1],msig[,-1])

# 4. concat the data frames

# without bulk freq for building the signature matrix
msig_stable <- bind_cols(muts_all.df,msig_all)

# with bulk freq for export and overview
msig_stable_complete <- bind_cols(muts_all.df,msig_all,bulk_all.df)
```


```{r collapse_identicals, message=F, warning=F, include = FALSE, eval = executeDeconvolution}
# When multiple columns look like the same, the deconvolution will not work, because the function can't distinguish 
# between those columns. The workaround for now is to identify those equal columns and merge them into one, returning also
# a vector with the information about which of the columns were merged. 

msig_stable_unique <- dedupe(msig_stable)
# TODO this does not group columns correctly -> see comment at "dedupe" and PR #48
```
```{r deconvolution, message=F, warning=F, include = FALSE, eval = executeDeconvolution}

sig <- msig_stable_unique[, -which( names(msig_stable_unique) %in% "muts" )]  
variant_abundance <- deconv(as.numeric(bulk_all),sig)

```
`r if (executeDeconvolution){"The following bar plot shows the percentage of each VOCs in the sample as predicted by the
deconvolution model. If it is not possible to identify a unique VOC from the reported mutation, 
the column description shows all VOCs which are realted to the signature mutation."}` 

```{r plot, message=F, warning=F, echo = FALSE, eval = executeDeconvolution}

Variant_colors <- c("#8a3874", "#4d3da1", "#62c742", "#13317a", "#86e5a3", "#6f69e5", "#4cdab2", "#999ce4", "#2ce6f3",
"#6638c6", "#005f29", "#5d73cc", "#616524", "#a8a041", "#e9f600", "#3eaca8", "#62a273", "#4ea5d0", "#655c95", "#67a04e")
# TODO this shoul be put into a seperate color palette function in a seperate file

# work in progress...only to show how it theoretically can look like in the report
variants <- colnames(msig_stable_unique[,-1])
df <- data.frame(rbind(variant_abundance))

# XXX: Replace the long column name consisting of concatenated variant
# names with "others" and put the variant names in a label.
# TODO: This should be done much earlier when building the data frame.

condensed_variants_names <-
    unlist(lapply(variants, function (x) { if (str_detect(x, ",")) { "others" } else { x }}))

colnames(df) <- condensed_variants_names

variants_labels <-
    unlist(lapply(variants, function (x) str_replace_all(x, ",", "\n")))

df <- df %>% 
    tidyr::pivot_longer(everything())

font_family <- "DejaVu Sans"

 ggplot(data = df, aes(name,value, 
                       fill = name)) +
        geom_bar(stat="identity") +
        labs(title = "Proportion of variants of concern inferred from deconvolution",
             x = "Variants",
             y = "Percentage") +
        scale_x_discrete(limits = condensed_variants_names) +
        scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.1),
                           labels = scales::percent_format(accuracy = 1)) +
        scale_colour_manual(values=Variant_colors) + 
        # geom_text ignores the theme's default font family, so we
        # need to provide it here.
        geom_text(aes(family = font_family,
                      label = sprintf("%0.3f", round(value, digits = 3))),
                      position=position_dodge(width=0.9), 
                      vjust=-0.25) + 
     scale_fill_discrete(name = "Variants",
                         breaks = condensed_variants_names,
                         labels = variants_labels) +
     theme_gray(base_family = font_family)
```

# Methods
## LoFreq filter
| LoFreq is used with default filter settings:       |                   |
|:---------------------------------------------------|:------------------|
| minimum coverage                                   | 10                |
| Strand-Bias Multiple Testing Correction, fdr corr. | pvalue > 0.001000 |
| Minimum SNV Quality (Phred)                        | 63                |
| Minimum Indel Quality (Phred)                      | 47                |

## VEP settings  
* Species: SARS-CoV-2  
* Assembly: ASM985889v3  

|                                                   |        |
|:--------------------------------------------------|:-------|
| Matched Annotations from NCBI and EMBL-EBI (MANE) | yes    |
| Restrict results by severity of consequence       | no     |
| upstream/downstream distance                      | 5000bp |


# Raw data 

```{r download_raw, include = F}
# make raw/input data downloadable
snvs <- readLines(params$snv_file) %>% paste0(collapse="\n") %>% base64_urlencode()
vep <- readLines(params$vep_file) %>% paste0(collapse="\n") %>% base64_urlencode()
```
Called SNVs:  
[Download SNVs.csv](`r sprintf('data:text/csv;base64,%s', snvs)`)

Variant effect prediction (*Ensemble VEP output*):  
[Download VEP_out.csv](`r sprintf('data:text/csv;base64,%s', vep)`)

```{r csv_output_variant_plot, include = F, eval = executeDeconvolution}
# prepare processed variant values to output them as a csv which will be used for the plots in index.rmd
# those outputs are not offically declared as outputs which can lead to issues - that part should be handled by a seperate 
# file (and maybe rule)
# get all possible variants
all_variants <- colnames (msig_all)
output_variants <- file.path(csv_output_dir, "data_variant_plot.csv")

# if file exists already - grep the existing content and add a new line
if (file.exists (output_variants)) {
    output_variant_plot <- read.table (output_variants, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_variant_plot <- data.frame (samplename = character(), 
                                       dates = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (variant in all_variants) {
      output_variant_plot[,variant] <- numeric()
    }
    
  #write header line
  write.table(t(colnames(output_variant_plot)), output_variants, sep = "\t", 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
}
# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_variant_plot <- bind_rows(output_variant_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_variant_plot$samplename))

# write deconv values to df
for (i in all_variants){
  if (i %in% df$name){
    # check if variant already has a column
    if (i %in% colnames(output_variant_plot)) {
        output_variant_plot[sample_row,][i] <- df$value[df$name == i]
    }
  }
}
write.table(output_variant_plot[sample_row,], output_variants, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
```{r csv_output_mutation_plot, message = FALSE, warning = FALSE, include = FALSE}
# prepare processed mutation values to output them as a csv which will be used for the plots in index.rmd
# those outputs are not offically declared as outputs which can lead to issues - that part should be handled by a seperate 
# file (and maybe rule)
 
# only one mutation disregarding variants
# TODO: that problem should be fixed already further above by deduplicating for the tables, check and consider that 
# data frame from above
match.df <- unique(match.df)
# get all possible mutations
all_mutations <- sigmuts_deduped$value
output_mutations <- file.path(csv_output_dir, "data_mutation_plot.csv")


if (file.exists (output_mutations)) {
    output_mutation_plot <- read.table (output_mutations, 
                                       sep = "\t", header = TRUE, colClasses = "character")
} else {
    output_mutation_plot <- data.frame (samplename = character(),
                                       dates = character(),
                                       location_name = character(),
                                       coordinates_lat = character(),
                                       coordinates_long = character())

    # add columns for all possible variants to the dataframe
    for (mutation in all_mutations) {
      output_mutation_plot[,mutation] <- numeric()
    }
    #write header line
    write.table(t(colnames(output_mutation_plot)), output_mutations, sep = "\t", 
                  row.names = FALSE, col.names = FALSE, quote = FALSE)
}

# adding new row
meta_data <- c (samplename = sample_name,
                dates = date,
                location_name = location_name,
                coordinates_lat = coordinates_lat,
                coordinates_long = coordinates_long
)
output_mutation_plot <- bind_rows(output_mutation_plot, meta_data)

# get rownumber for current sample
sample_row <- which(grepl(sample_name, output_mutation_plot$samplename))

# write mutation frequency values to df
for (i in all_mutations){
  if (i %in% match.df$AA_mut){
    # check if variant already has a column
    if (i %in% colnames(output_mutation_plot)) {
        output_mutation_plot[sample_row,][i] <- match.df$freq[match.df$AA_mut == i]
    }
  }
}
write.table(output_mutation_plot[sample_row,], output_mutations, sep = "\t", append = TRUE, 
            na = "NA", row.names = FALSE, col.names = FALSE, quote = FALSE)
```
