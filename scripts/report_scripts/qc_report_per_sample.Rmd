---
title: "SARS-CoV-2 QC report"
nav: "Quality control"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params:
  sample_name: ''
  coverage_file: ''
  multiqc_report: ''
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(dplyr)
library(DT)
library(magrittr)
library(base64url)
```

# Input Settings

### Sample: `r params$sample_name`
```{r reading data, include = FALSE}
coverage.df <- read.table(params$coverage_file, sep = "\t", header = T)
coverage.df <- na_if(coverage.df, "[]")
coverage.df <- gsub('\\[','',coverage.df)
coverage.df <- gsub('\\]','',coverage.df)
# fixme: this can be sure done in a nicer and more compact way
```
# Coverage reports
## Number of amplicons covered

The table below shows how many amplicons are covered. Since paired read alignement is used it is distiguished between:  
* **fully covered** - covered by both strands  
* **partially covered** - covered only by one strand  
* **drop out** - not covered.  
This is important to know to see if regions and genes which could carry mutations of particular interest are covered or not. 
The information about the amplicon primer was taken from the [ARTIC bioinformatics platform](https://github.com/joshquick/artic-ncov2019/blob/master/primer_schemes/nCoV-2019/V3/nCoV-2019.bed).
The name of the reference sequence version ["MN908947.3"](https://www.ncbi.nlm.nih.gov/nuccore/MN908947) was changed 
to ["NC_045512.2"](https://www.ncbi.nlm.nih.gov/nuccore/1798174254). Those versions of the SARS-CoV-2 reference genome 
are identical.
 
```{r, message=F, warning=F, echo = FALSE}

AmpliconCoverage <- data.frame("Number of amplicon fully covered" = paste0(coverage.df[1],' out of 98'), 
                               "Amplicons partially covered" = coverage.df[2],
                               "Drop-out amplicons" = coverage.df[3]) # maybe more clear title stating which coverage

datatable(t(AmpliconCoverage), options = list(searching = FALSE, paging = FALSE))

```

## Read coverage  
This table shows the number of aligned reads, the mean coverage depth and percentage of the reference genome covered by 
pre-processed reads. Preprocessing was done by [*Prinseq*](http://prinseq.sourceforge.net/index.html) with setting given by 
the [setting_file](https://github.com/BIMSBbioinfo/pigx_sarscov2_ww/blob/main/documentation/user_installation_doc.md#settings-file-and-sample-sheet).  

```{r, message=F, warning=F, echo = FALSE}

Coverage <- data.frame("Total coverage" = coverage.df[4], 
                       "Aligned reads" = paste(round(as.integer(coverage.df[5]),1),"%"),
                       "Mean depth" = round(as.integer(coverage.df[6]))) # maybe more clear title stating which coverage

datatable(t(Coverage), options = list(searching = FALSE, paging = FALSE))

```

# Quality control and preprocessing

## MultiQC 

A quality control report has been created using [*MultiQC*](https://multiqc.info/). This report should be consulted in particular if there are
any issues with low alignment rates or a high match rate of SARS-CoV-2 by *Kraken2* (see Kraken reports). 

Download: [MultiQC report of raw and processed data](`r params$multiqc_report`)

## Trimming

To improve alignment rates and mutation calling proper trimming of reads should be considered e.g. based on the provided
fastqc-reports. Read preprocessing is performed by [*Prinseq*](http://prinseq.sourceforge.net/index.html).

This sample was processed with these settings:

|      |     |  
|:-----|:----|  
|trim length cutoff prinseq |0.2|

## Download Stats csv
```{r, include = F}

write.csv2(coverage.df, file.path(dirname(params$coverage_file), "report_download_coverage.csv")) # not sure about the funct of the dataframe here, but it works so I leave it for now

coverage <- readLines(params$coverage_file) %>% paste0(collapse="\n") %>% base64_urlencode()
```
Coverage statistics:  
[Download Coverage_stats.csv](`r sprintf('data:text/csv;base64,%s', coverage)`)

