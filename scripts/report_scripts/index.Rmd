---
title: "SARS-CoV-2 Wastewater Sampling Reports"
nav: "Overview"
author: "BIMSB Bioinformatics Platform"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params:
  variants_csv: ''
  mutations_csv: ''
  coverage_dir: ''
  sample_sheet: ''
  mutation_sheet: ''
  logo: ''
  fun_cvrg_scr: ''
  fun_lm: ''
  fun_tbls: ''
  fun_pool: ''
  overviewQC: ''
  output_dir: ''
---

<style>
.pigx_info {
  background-image: url(params$logo);
}

.notice {
  margin-left: -12px;
  padding-left: 6px;
  border-left: 6px solid #ff9999;
}
.dropdown-menu {
  max-height: 200px;
  overflow-y: scroll;}

</style>

<div id="logo" align="top">
`r knitr::include_graphics(params$logo)`
</div>


```{r libraries_and_input, echo=F, message=F, warning=F}
library(plotly)
library(htmltools)
library(reshape2)
library(base64url)
library(DT)
library(data.table)
library(stringr)
library(ggplot2)
library(dplyr)
library(viridis)

df_var <- read.table(params$variants_csv, sep = "\t", header=TRUE, check.names = FALSE)
df_mut <- read.table(params$mutations_csv, sep = "\t", header=TRUE, check.names = FALSE)

# function for downloadable tables
create_dt <- function(x){
  DT::datatable(x, options = list(fixedColumns = TRUE, 
                               scrollY = 180,
                               scrollX = TRUE,
                               scroller = TRUE, 
                               dom = 'Slfrtip'))
}
```

This pipeline performs mutation analysis of SARS-CoV-2 and reports and quantifies the occurrence of
*variants of concern* (VOC) and signature mutations by which they are characterised.

The visualizations below provide an overview of the evolution of VOCs found
in the analyzed samples across given time points and locations. The abundance values for the variants are derived 
by deconvolution (for details please see the [variant report](https://bimsbstatic.mdc-berlin.de/akalin/PiGx/sars-cov2-ww/example_report/WW_210304_KW1.variantreport_p_sample.html#2_Deconvolution)) 
The frequencies of the mutations are the output of [LoFreq](https://csb5.github.io/lofreq/).

This pipeline is part of
[PiGx](https://bioinformatics.mdc-berlin.de/pigx), a collection of
highly reproducible genomics pipelines
[developed](https://github.com/BIMSBbioinfo/pigx_sarscov2_ww) by the
[Bioinformatics & Omics Data Science
platform](https://bioinformatics.mdc-berlin.de/) at the Berlin
Institute of Medical System Biology (BIMSB).

```{r sample_quality_score, echo=FALSE, message=FALSE, warning=FALSE}
source(params$fun_cvrg_scr) # TODO given as input? or only the scripts dir? similar variant_report

coverages.df <- merge(get_genome_cov( params$coverage_dir ), get_mutation_cov( params$coverage_dir), by="samplename")
coverages.df$proport_muts_covered <- round((as.numeric(coverages.df$total_muts_cvrd) * 100)/as.numeric(coverages.df$total_num_muts), 1)

if ( !(length(coverages.df) == 0)){
    # take only the samples with > 90% mutation coverage
    good_samples.df <- coverages.df %>% filter( as.numeric(proport_muts_covered) >= 90) # TODO stringecy should be given by user, maybe even through visualization
    bad_samples.df <- coverages.df %>% filter( !(samplename %in% good_samples.df$samplename))
} else {
    cat("\n No coverage values found.")
}
```
# Variants Of Concern

These plots provide an overview of the relative frequencies of
identified variants of concern (VOC) of SARS-CoV-2 at specific
wastewater sampling locations over time.

```{r filter_plot_frames_samplescore, echo=F, message=F, warning=F}
source(params$fun_pool)

# only use good samples for processing and visualiztaion
approved_var_plot <- df_var %>% filter( samplename  %in% good_samples.df$samplename )
approved_var_plot <- unique(approved_var_plot)
approved_mut_plot <- df_mut %>% filter( samplename  %in% good_samples.df$samplename )
# pool the samples per day, discard locations
weights <- read.csv(params$overviewQC, header = TRUE, check.names = FALSE)
weights <- weights %>% dplyr::select( c(samplename, total_reads))
approved_var_plot_location_pooled <- pool_by_weighted_mean(approved_var_plot, weights, "day_location")

```
## Frequency of variants of concern over time for each location

These plots show the relative frequency of detected variants of
concern in samples at specific wastewater sampling locations, and how
the frequencies change over time.

Since not all variants of concern are listed, the relative
frequencies at a given location and time will not necessarily add up
to one.
```{r color_palette, echo=F, message=F, warning=F}
Variant_colors <- c("#8a3874", "#4d3da1", "#62c742", "#13317a", "#86e5a3", "#6f69e5", "#4cdab2", "#999ce4", "#2ce6f3",
"#6638c6", "#005f29", "#5d73cc", "#616524", "#a8a041", "#e9f600", "#3eaca8", "#62a273", "#4ea5d0", "#655c95", "#67a04e")
```
```{r variants_pooled, message = FALSE, echo = FALSE}
melted <- reshape2::melt(approved_var_plot_location_pooled,
                         id.vars = c("dates", "samplename"))
p_variant_pooled <- subset(melted) %>%
   group_by(dates) %>%
   arrange(variable) %>%
   mutate (value = round (value, 4)) %>%
   plot_ly (type = 'scatter',
            mode = 'lines+markers',
            stackgroup = 'one',
            showlegend = TRUE,
            name = ~variable,
            x = ~dates,
            y = ~value,
            color = ~variable,
            colors = viridis_pal(option = "D")(6)) %>%
   layout (title = "Summary over time",
           showlegend = TRUE,
           yaxis = list(title = "Frequency"))
```
## Proportions of Variants Of Concern {.tabset .tabset-fade}
```{r tab_plotting_variants, message = FALSE, echo = FALSE, results='asis', fig.width=4, fig.height=4}
# Get the current figure size in pixels:
get_w <- function() {
  with(knitr::opts_current$get(c("fig.width", "dpi", "fig.retina")),
       fig.width*dpi/fig.retina)
}

get_h <- function() {
  with(knitr::opts_current$get(c("fig.height", "dpi", "fig.retina")),
       fig.height*dpi/fig.retina)
}

# plot variant frequencies by location, no pooling
melted <- reshape2::melt(approved_var_plot,
                         id.vars = c("dates", "samplename", "location_name",
                                     "coordinates_lat", "coordinates_long"))
locations <- unique(melted$location_name)
location_plot <- function (loc) {
                   subset(melted, location_name == loc) %>%
                       group_by(dates) %>%
                       arrange(variable) %>%
                       mutate (value = round (value, 4)) %>%
                       plot_ly (type = 'scatter',
                                mode = 'lines+markers',
                                stackgroup = 'one',
                                showlegend = TRUE,
                                name = ~variable,
                                x = ~dates,
                                y = ~value,
                                color = ~variable,
                                colors = viridis_pal(option = "D")(6)) %>%
                       layout (title = location,
                               showlegend = TRUE,
                               yaxis = list(title = "Frequency"))
}
plot_list <- list()
for ( i in seq_along(locations)) {
  plot_name <- locations[i]
  df <- paste0(locations[i],".df")
  plot_name <- location_plot(locations[i])
  plot_list[[i]] <- plot_name
}

cat("###", 'Summary over all locations', '{-}', '\n\n')
print(htmltools::tagList(ggplotly(p_variant_pooled)))
cat('\n\n')
for (i in 1:length(locations)){
  cat("###", locations[i], '{-}', '\n\n')
  print(htmltools::tagList( ggplotly ( plot_list[[i]])))
    cat('\n\n')
}
```


## Variants of concern per date and location

This plot visualizes the development of local outbreaks and the
proportions of identified VOCs in that area.  The gray marker at every
sampling location is overlayed by a colored disks for every variant.

<div class="notice">
Locations of wastewater processing plants have been generated arbitrarily and do 
not correspond to actual locations.
</div>

Use the slider to select a specific date or hit the *Play* button to
display all snapshots successively.  Click on a variant in the legend
to toggle its visibility in the map; double-click to view only the
selected variant.

```{r maps_for_variants, echo=F, message=FALSE, warning=FALSE, out.width="900px", out.height="900px"}
if (nrow(approved_var_plot) > 0 ){ # check if filtered dataframe has actual values
    approved_var_plot_day_pooled  <- pool_by_weighted_mean(approved_var_plot, weights, "day")
    
  melted <- melt(approved_var_plot_day_pooled,
                   id.vars = c("dates", "samplename", "location_name",
                               "coordinates_lat", "coordinates_long"),
                   rm.NA = TRUE) %>%
        mutate (value = round (value, 4))
    
    locations <- approved_var_plot_day_pooled %>% mutate( dates = as.character( strptime(dates, format = "%Y-%m-%d"))) %>%
                 melt( id.vars = c("coordinates_lat", "coordinates_long"))
                                                          
    plot_ly (type = 'scattermapbox',
             mode = 'markers',
             colors = viridis_pal(option = "D")(6),
                               width = 900,
                               height = 500) %>%
        add_trace(data = locations,
                  size = 1,
                  lon = ~coordinates_long,
                  lat = ~coordinates_lat,
                  opacity = 0.1,
                  showlegend = FALSE,
                  hoverinfo = 'none',
                  marker = list(sizemode = 'diameter',
                                color = 'rgb(150, 150, 150)',
                                opacity = 0)) %>%
        add_trace(data = melted,
                  lat = ~coordinates_lat,
                  lon = ~coordinates_long,
                  legendgroup = ~variable,
                  showlegend = TRUE,
                   frame = ~as.character( strptime(dates, format = "%Y-%m-%d")),
                  size = ~value,
                  color = ~variable,
                  hoverinfo = 'text+name',
                  hovertext = ~paste0("Frequency: ", value),
                  marker = list (sizemode = 'diameter')) %>%
        layout (mapbox = list (zoom = 5.5,
                               center = list(lat = ~median(coordinates_lat, na.rm=TRUE),
                                             lon = ~median(coordinates_long, na.rm=TRUE)),
                               style = 'open-street-map'))
}
```

# Signature Mutations

Signature mutations are characterizing variants of concern (VOC) of
SARS-CoV-2.  The following plots provide an overview of detected
mutations in different locations, and how their relative frequency
changes over time.

Note that these plots only display signature mutations which where
reported for VOCs.

## Mutations by location

WIP: To show the dynamic of significantly changing mutations over time.... 
As a first step...linear regression. The following table shows the most significant mutations, also indicating if increasing or decreasing.
```{r title_lm_table, echo = FALSE, results = 'asis'}
cat("\n Mutations with significant increase in frequency over time")
```
### linear regression 
```{r linear_regression, echo=F, message=F, warning=F}
source(params$fun_lm)
mutation_sheet <- params$mutation_sheet
sigmuts.df <- na_if( read.csv(mutation_sheet, header = TRUE), "" ) 
# split gene name of for easier matching
sigmuts.df <- sigmuts.df %>% mutate_all( funs(str_replace(.,'^[^:]*:','')))
if (nrow(approved_mut_plot) > 0){
    changing_muts <- parsing_mutation_plot_data( approved_mut_plot )
    mutations_sig_unfiltered <- refined_lm_model( changing_muts )
    mutations_sig <- filter_lm_res_top20( mutations_sig_unfiltered, 0.05 )

  
  if (nrow(mutations_sig) > 0){
  # flag if mutation is signature mutation
    mutations_sig <- mutations_sig %>% 
      rowwise() %>%
      mutate( sigflag = ifelse( any(sigmuts.df == str_split(mutation, "::")[[1]][2]), "SigMut",'') ) }
  # filter good samples for only mutations with sig pvalues for plotting
    approved_mut_plot <- dplyr::select(approved_mut_plot, c(samplename, dates, location_name,
                                                     coordinates_lat, coordinates_long, 
                                                     mutations_sig$mutation))
    approved_mut_plot_location_pooled <- pool_by_mean(approved_mut_plot, na_handling = TRUE, group_fun = "day_location")
  mutations_sig_download <- mutations_sig %>% paste0(collapse="\n") %>% base64url::base64_urlencode()
    create_dt(mutations_sig)
} else { create_dt(mutations_sig) }
if (nrow(mutations_sig_unfiltered) > 0){  
    mutations_sig_unfiltered <- mutations_sig_unfiltered %>%
      rowwise() %>%
      mutate( sigflag = ifelse( any(sigmuts.df == str_split(mutation, "::")[[1]][2]), "sigmut", ''))}
    mutations_sig_unfiltered_download <- mutations_sig_unfiltered %>% paste0(collapse="\n") %>% base64url::base64_urlencode()


```
### Download linear regression results:
[Download significant_mutations.csv](`r sprintf('data:text/csv;base64,%s', mutations_sig_download)`) (only p-values)    
[Download lm_res_all_mutations.csv](`r sprintf('data:text/csv;base64,%s', mutations_sig_unfiltered_download)`) (p-values, coefficients)


These plots show the relative frequency of detected signature
mutations in samples at specific wastewater sampling locations, and
how the frequencies change over time.

```{r mutations_pooled, echo = FALSE, message = FALSE, warning = FALSE}

if (length(approved_mut_plot_location_pooled) > 2){
  melted <- melt(approved_mut_plot_location_pooled,
                   id.vars = c("dates", "samplename"))
# flag if mutation is signature mutation
  melted <- melted %>%
  rowwise() %>%
  mutate( sigflag = ifelse( any(sigmuts.df == str_split(variable, "::")[[1]][2]), "SigMut",'') ) %>%
  ungroup()  
    # sort by dates
    idx <- order(melted$dates)
    melted <- melted[idx, ]
    melted$sigflag[is.na(melted$sigflag)] <- "nosigmut"
p_mutations_pooled <- subset(melted) %>%
       group_by(dates) %>%
       arrange(variable) %>%
       ungroup() %>%
       plot_ly(type = 'scatter', 
               mode = "lines+markes",
               symbol = ~ sigflag,
               symbols = c('circle','square'),
               x = ~ dates,
               y = ~ value,
               name = ~variable,
               connectgaps = TRUE, 
               color = ~ variable,
               colors = viridis_pal(option = "H")(20)
       ) %>%
       layout(title = summary,
              yaxis = list(title = "Frequency"))
} # mke sure there are other columns except the name and date
```
## Significantly increasing mutations over time {.tabset .tabset-fade}
```{r tab_plotting_mutations, echo = FALSE, message = FALSE, warning = FALSE, results='asis', fig.width=4, fig.height=4}

plot_muts <- function (location) {
                       subset(melted, location_name == location) %>%
                           group_by(dates) %>%
                           arrange(variable) %>%
                           ungroup() %>%
                       plot_ly(type = 'scatter', 
                               mode = "lines+markes",
                               symbol = ~sigflag,
                               symbols = c('circle','hourglass'),
                               x = ~dates,
                               y = ~value,
                               name = ~variable,
                               color = ~ variable,
                               colors = viridis_pal(option = "H")(20),
                               connectgaps = TRUE
                               ) %>%
                           layout(title = location,
                                  yaxis = list(title = "Frequency"))
}

if (length(approved_mut_plot)>5){ # TODO check if the filtered df has actual values besides meta data
  
    melted <- melt(approved_mut_plot,
                   id.vars = c("dates", "samplename", "location_name",
                               "coordinates_lat", "coordinates_long")) %>%
             rowwise() %>%
             mutate( sigflag = ifelse( any(sigmuts.df == str_split(variable, "::")[[1]][2]), "SigMut",'') )
    # sort by dates
    idx <- order(melted$dates)
    melted <- melted[idx, ]
    
    locations <- unique(melted$location_name)

    plot_list <- list()
    for ( i in seq_along(locations)) {
      plot_name <- locations[i]
      df <- paste0(locations[i],".df")
      plot_name <- plot_muts(locations[i])
      plot_list[[i]] <- plot_name
    }
    
    cat("###", 'Summary over all locations', '{-}', '\n\n')
    print(htmltools::tagList(ggplotly(p_mutations_pooled)))
    cat('\n\n')
    for (i in 1:length(locations)){
      cat("###", locations[i], '{-}', '\n\n')
      print(htmltools::tagList( ggplotly ( plot_list[[i]])))
        cat('\n\n')
    }
}

```
## Signature mutations by location

This plot visualizes the development of local outbreaks on the level
of single mutations.  The gray marker at every sampling location is
overlayed by a colored disks for each mutation.

<div class="notice">
Locations of wastewater processing plants have been generated arbitrarily and do 
not correspond to actual locations.
</div>

Use the slider to select a specific date or hit the *Play* button to
display all snapshots successively.

```{r mutations_for_locations_and_date, echo=F, message=F, warning=F, out.width="900px", out.height="900px"}
# TODO: remove the light gray date description from the plot
# TODO: find a way to only show dynamic of one single mutation over the whole time
    
if (nrow(approved_mut_plot) > 0 && length(approved_mut_plot)>5){ # check if the filtered df has actual values besides meta data
       approved_mut_plot_day_pooled  <- pool_by_mean(approved_mut_plot, TRUE, "day")
  
    

  
    melted <- melt(approved_mut_plot_day_pooled,
                   id.vars = c("dates", "samplename", "location_name",
                               "coordinates_lat", "coordinates_long"),
                   rm.NA = TRUE) 
     # check if there are actual values except the meta data
      melted <- melted %>% mutate (value = round (value, 4))
    
   locations <- approved_mut_plot_day_pooled %>% mutate( dates = as.character( strptime(dates, format = "%Y-%m-%d"))) %>%
                 melt( id.vars = c("coordinates_lat", "coordinates_long"))
    
    plot_ly (type = 'scattermapbox',
             colors = viridis_pal(option = "H")(20),
             mode = 'markers',
                               width = 900,
                               height = 500) %>%
        add_trace(size = 1,
                  data = locations,
                  lon = ~coordinates_long,
                  lat = ~coordinates_lat,
                  opacity = 0.1,
                  showlegend = FALSE,
                  hoverinfo = 'none',
                  marker = list(sizemode = 'diameter',
                                color = 'rgb(150, 150, 150)',
                                opacity = 0)) %>%
        add_trace(data = melted,
                  lat = ~coordinates_lat,
                  lon = ~coordinates_long,
                  legendgroup = ~variable,
                  showlegend = TRUE,
                  frame = ~as.character( strptime(dates, format = "%Y-%m-%d")),
                  size = ~value,
                  color = ~variable,
                  hoverinfo = 'text+name',
                  hovertext = ~paste0("Frequency: ", value),
                  marker = list (sizemode = 'diameter')) %>%
    
        layout (title = ~dates,
                autosize = TRUE,
                mapbox = list (zoom = 5.5,
                               center = list(lat = ~median(coordinates_lat, na.rm=TRUE),
                                             lon = ~median(coordinates_long, na.rm=TRUE)),
                               style = 'open-street-map'))
}
```

## Raw data summaries and download

```{r table_var_frqs, echo = FALSE}
df_var_download <- df_var %>% paste0(collapse="\n") %>% base64_urlencode()
```
### Frequencies per variant per sample, derived by deconvollution, pooled by weighted mean by read number")
[Download variant_frequencies.csv](`r sprintf('data:text/csv;base64,%s', df_var_download)`)

```{r table_mut_freqs, echo = FALSE}
df_mut_download <- df_mut %>% paste0(collapse="\n") %>% base64_urlencode()
```
### Frequencies per mutation per sample
[Download mutation_frequencies.csv](`r sprintf('data:text/csv;base64,%s', df_mut_download)`)


```{r mutation_counts, message = FALSE, echo = FALSE}
# get functions for counting and writing
source(params$fun_tbls)

# make the mutation count frame
count_frame <- write_mutations_count(df_mut, sigmuts.df, mutations_sig)
output_dir <- params$output_dir

# write to file
write.csv(count_frame, file.path(output_dir, "mutations_counts.csv"), 
         na = "NA", row.names = FALSE, quote = FALSE)
write.csv(mutations_sig_unfiltered, file.path(output_dir, "linear_regression_results.csv"),
          na = "NA", row.names = FALSE, quote = FALSE)

# show and make downloadable
count_frame <- count_frame %>% paste0(collapse="\n") %>% base64_urlencode()
``` 
### Counts of mutations found across all sample and per sample
[Download mutation_counts.csv](`r sprintf('data:text/csv;base64,%s', count_frame)`)

# Detailed per-sample reports

For every sample three reports are generated:  
    
  * a QC report reporting general statistics and amplicon coverage  
  * a variant report including tables summarizing the mutation
    calling and the deconvolution results for the abundance of VOCs  
  * a taxonomic classification report including a pie chart showing the
    analysis of the unaligned reads.

The reports for each sample can be accessed here:

```{r generate overview, warning=F, message=F}

sample_sheet <- fread(params$sample_sheet)
sample_names <- sample_sheet$name
reports <- list(list("suffix" = ".variantreport_p_sample.html",
                     "name"   = "variant report"),
                list("suffix" = ".qc_report_per_sample.html",
                     "name"   = "QC report"),
                list("suffix" = ".taxonomic_classification.html",
                     "name"   = "taxonomic classification"))

df <- as.data.frame( dplyr::select(sample_sheet, name, location_name, date) )

links <- lapply(sample_names, function (sample) {
    as.vector(lapply(reports, function (report) {
        paste0("<a href=", sample, report$suffix, ">", report$name, "</a>")
    }))
})
df$reports <- links

datatable(df, options = list( fixedColumns = TRUE, 
                               scrollY = 180,
                               scrollX = TRUE,
                               scroller = TRUE,
                               dom = 'Slfrtip'))
```
## Discarded samples after alignment quality control
```{r title_quality_score, echo=FALSE, message=FALSE, warning=FALSE, results = 'asis'}
    # table displaying bad samples which are not further inlcuded 
    cat("\n Table 1: Samples without sufficient amplicon coverage. They aren't included in the visualization or the linear regression") # TODO refine this text
 ```

```{r table_ample_quality_score, echo=FALSE, message=FALSE, warning=FALSE}
if ( !(length(coverages.df) == 0)){
    # TODO refine column names --> e.g "coverage in percent", 
    bad_samples.df <- bad_samples.df %>% slice_head(n=20)
    create_dt(bad_samples.df)
} else {
    cat("\n No coverage values found.")
}
```
