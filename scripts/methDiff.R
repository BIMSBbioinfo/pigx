# PiGx BSseq Pipeline.
#
# Copyright Â© 2018 Alexander Gosdschan <alexander.gosdschan@mdc-berlin.de>
#
# This file is part of the PiGx BSseq Pipeline.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

## Collect arguments
args <- commandArgs(TRUE)

## Default setting when no arguments passed
if(length(args) < 1) {
  args <- c("--help")
}

## Help section
if("--help" %in% args) {
  cat("
      Render to report
      
      Arguments:
      --inputfiles list of methylation call files generated by methyl-calling
      --methylDiff_file name of RDS file containing complete methylDiff object
      --meth.diff minimum methylation difference to detect (default: 0.25)
      --qvlaue minimum q.value to detect significant differentially methylated bases (0.01)
      --methylDiff_hyper_file name of RDS file containing hypermethylated subset of methylDiff object
      --methylDiff_hypo_file name of RDS file containing hypomethylated subset of methylDiff object
      --outBed name of BED file containing differentially methylated CpGs
      --assembly assembly to be used in methlyDiff object
      --treatment list of treatment values in same order as input files
      --mincov minimum coverage (default: 10)
      --workdir current working directory 
      --cores number of cores to use for calculateDiffMeth
      --logFile file to print the logs to
      --help              - print this text
      
      Example:
      ./test.R --arg1=1 --arg2='output.txt' --arg3=TRUE \n\n")
  
  q(save="no")
}

## Parse arguments (we expect the form --arg=value)
parseArgs <- function(x) strsplit(sub("^--", "", x), "=")
parseArgsList <- function(x) strsplit(as.character(x), " ")

argsDF <- as.data.frame(do.call("rbind", parseArgs(args)))

argsL <- as.list(as.character(argsDF$V2))
names(argsL) <- argsDF$V1

argsL <- sapply(argsL,parseArgsList)


## catch output and messages into log file
out <- file(argsL$logFile, open = "wt")
sink(out,type = "output")
sink(out, type = "message")



# Run Functions -----------------------------------------------------------

## Differential methylation report

## load libraries
library("methylKit")

input     <- argsL$inputfiles
sampleids <- argsL$sampleids
output    <- argsL$outBed
methylDiff_file   <- argsL$methylDiff_file
methylDiff_hyper_file    <- argsL$methylDiff_hyper_file
methylDiff_hypo_file   <- argsL$methylDiff_hypo_file
assembly  <- argsL$assembly
treatment <- as.numeric(argsL$treatment)
mincov    <- as.numeric(argsL$mincov)
workdir   <- argsL$workdir
cores     <- as.numeric(argsL$cores)
difference <- as.numeric(argsL$difference)
qvalue <- as.numeric(argsL$qvalue)




### Find differentially methylated cytosines


#' Combine multiple methylRaw objects into a methylRawList object
#' 
#' @param list.of.methylRaw a list of methylRaw objects from the methylKit package
#' @param treatment a numeric vector indicating treaments
combine2methylRawList <- function(list.of.methylRaw, treatment, min.cov) {
  
  ## check if treatment has same length as number of inputs 
  if(length(list.of.methylRaw)!=length(treatment))
    stop("Treatment vector doesnt have the same length as list of methylRaw objects.")
  
  ## check if input is really of type methylRaw 
  if(!all(sapply(list.of.methylRaw, function(x) class(x)=="methylRaw")))
    stop("Input objects are not methylRaw objects.")
  
  ## remove data beyond min coverage
  list.of.methylRaw.mincov = lapply(1:length(list.of.methylRaw), function(i){
    #which.gtmincov = which( getData(rds.objs[[i]])$coverage >= min.cov )
    which.gtmincov = which( rds.objs[[i]][[5]] >= min.cov )
    rds.objs[[i]][which.gtmincov,]
    })

  ## merge
  mrl <- new("methylRawList", list.of.methylRaw.mincov)
  mrl@treatment <- treatment
  mrl
}

# Read input files
inputfiles = paste0(workdir, input)
rds.objs = lapply(inputfiles, readRDS)

methRawList.obj = combine2methylRawList(rds.objs, treatment, mincov)

# Take bases with coverage in all samples.
meth.unite=unite(methRawList.obj, destrand=FALSE)

meth.unite.nonempty = nrow(meth.unite)>1
if(!meth.unite.nonempty) print("There are no bases with coverage in all samples")

if(nrow(meth.unite)>1){
  
  meth.diffmeth <- calculateDiffMeth(meth.unite, 
                                     overdispersion="MN",
                                     adjust = "fdr",
                                     test="Chisq",
                                     mc.cores=cores) 
  
  # Get differentially methylated bases based on cutoffs  
  methylDiff.obj = getMethylDiff(meth.diffmeth, 
                                 difference=difference,
                                 type="all",
                                 qvalue=qvalue)
  # Get hypo-methylated
  methylDiff.obj.hypo = getMethylDiff(meth.diffmeth,
                                      difference=difference,
                                      type="hypo",
                                      qvalue=qvalue)
  # Get hyper-methylated
  methylDiff.obj.hyper = getMethylDiff(meth.diffmeth,
                                       difference=difference,
                                       type="hyper",
                                       qvalue=qvalue)
  
}else{
  create.empty.methylDiff = function(sampleids, assembly, context, treatment){
    new("methylDiff",
        sample.ids = sampleids, 
        assembly = assembly,
        context = context,
        treatment=treatment,
        # strand.aware is set to FALSe by defualt in methylKit@1.3.3
        destranded=FALSE, 
        resolution="base"
    )
  }
  methylDiff.obj = create.empty.methylDiff(meth.unite@sample.ids, assembly, context, treatment)
  methylDiff.obj.hypo = create.empty.methylDiff(meth.unite@sample.ids, assembly, context, treatment)
  methylDiff.obj.hyper = create.empty.methylDiff(meth.unite@sample.ids, assembly, context, treatment)
  
}



# Check if there are some differentially methylated cytosines
methylDiff.nonempty = nrow(methylDiff.obj)>1
if(!methylDiff.nonempty) print("There are no differentially methylated cytosines")
meth.unite.or.methylDiff.nonempty = meth.unite.nonempty | methylDiff.nonempty



### Export differentially methylated cytosines

#' Export windows to a BED file
#' 
#' The windows are color coded based on their score (methylation or differential
#' methylation value).
#' 
#' @param windows \code{\link[GenomicRanges]{GRanges}} object with information about
#' differentially methylated regions
#' @param filename name of the output data
#' @param trackLine UCSC browser trackline
#' @param colramp color scale to be used in the BED display
#' defaults to gray,green, darkgreen scale.
#' 
#' @return A BED files with the differentially methylated regions
#' which can be visualized in the UCSC browser 
#' 
#' @seealso \code{\link{methylKit::methSeg2bed}}
#' 
#' @export
#' @docType methods
#' @rdname meth2bed
meth2bed<-function(windows,filename,
                   trackLine="track name='meth windows' description='meth windows' itemRgb=On",
                   colramp=colorRamp(c("gray","green", "darkgreen"))
){
  
  range01 <- function(x){(x-min(x)+1)/(max(x)-min(x)+1)}
  
  if(class(windows)!="GRanges"){
    windows=as(windows, "GRanges")
  }
  
  ## case if only one line is exported
  if(is.null(colramp) | length(windows)==1){
    trackLine <- gsub(pattern = "itemRgb=On",replacement = "",x = trackLine)
  } else {
    require(rtracklayer)
    ramp <- colramp
    score(windows)=range01(windows$meth.diff)
    mcols(windows)$itemRgb= rgb(ramp(score(windows)), maxColorValue = 255)     
  }
  
  strand(windows)="*"
  score(windows)=range01(windows$meth.diff)
  
  if(is.null(trackLine)){
    
    export.bed(windows,filename)
  }else{
    export.bed(windows,filename,
               trackLine=as(trackLine, "BasicTrackLine"))
  }
}


# Export differentially methylated cytosines to a bed file
trackLine = paste0("track name='differentially methylated cytosines ' ",
                   "description='diff. meth. between ",
                   paste(meth.diffmeth@sample.ids,collapse=","),
                   " mapped to ",
                   meth.diffmeth@assembly,
                   "' itemRgb=On")
meth2bed(windows = methylDiff.obj,
         trackLine=trackLine,
         colramp=colorRamp(c("gray","green", "darkgreen")),
         filename = output) 


# Save output of differential methylation calling into a RDS files
saveRDS(methylDiff.obj, methylDiff_file)
saveRDS(methylDiff.obj.hypo, methylDiff_hypo_file)
saveRDS(methylDiff.obj.hyper, methylDiff_hyper_file)

