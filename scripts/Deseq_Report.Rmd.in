---
title: "PiGx Chipseq - DESeq2 Report"
author: "BIMSB Bioinformatics Platform"
date: '`r format(as.POSIXct(if ("" != Sys.getenv("SOURCE_DATE_EPOCH")) { as.numeric(Sys.getenv("SOURCE_DATE_EPOCH")) } else { Sys.time() }, origin="1970-01-01"), "%Y-%m-%d %H:%M:%S")`'
params: 
  countDataFile: '/fast/AG_Tursun/agosdsc/projects/nida_atac_idha1/joinedFeatureCounts.tsv'
  colDataFile: '/home/agosdsc/projects/NulFatima_idha/2020_ATACseq_idha1vsFumGlut3Gln2/coldata_v2.tsv'
  gtfFile: '/fast/AG_Tursun/agosdsc/projects/nida_atac_idha1/Annotation/Processed_Annotation.rds'
  peakFile: '/fast/AG_Tursun/agosdsc/projects/nida_atac_idha1/Peaks/MACS2/all_samples/all_samples_peaks.narrowPeak'
  caseSampleGroups: 'idha1_ctrl'
  controlSampleGroups: 'N2' 
  covariates: ''
  groupCol: 'Group'
  useCustomBackground: FALSE
  rankedQuery: FALSE
  prefix: 'idha1_ctrl_vs_N2'
  workdir: '/fast/AG_Tursun/agosdsc/projects/nida_atac_idha1/Reports/'
  scriptdir: '~/projects/pigx/pigx_chipseq/scripts/'
  organism: 'celegans'
  logo: '/home/agosdsc/projects/pigx/pigx_chipseq/share/pigx_chipseq/Logo_PiGx.png'
---

<style>
#logo
{
    position: relative;
}
#logo img {
    /*position: relative;*/
    top: 25px;
    /*right: 0px;*/
    left: 50px;
    position: fixed;
    width: 125px;
    }
body
{
    position: absolute;
    top: 150px;
}
</style>

<div id="logo" align="top">
```{r echo=FALSE}
knitr::include_graphics(params$logo)
```
</div>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = params$workdir)
library(ggplot2)
library(ggrepel)
library(DESeq2)
library(DT)
library(pheatmap)
library(corrplot)
library(reshape2)
library(plotly)
library(scales)
library(crosstalk)
library(gprofiler2)
library(rtracklayer)
# library(SummarizedExperiment)
# library(GenomicRanges)
```

# Description

PiGx ChIPseq performs differential analysis using _DESeq2_, and produces this report. The report includes tables and figures summarizing similarities and differences between comparison groups as specified in the settings file. In addition to the differential analysis, there are plots and statistics for quality control of the experiment in general with an emphasis on the reproducibility of the sequencing results among the biological replicates.

This report was generated with PiGx ChIPseq version @VERSION@.

# Input Settings
```{r printInputSettings}

countDataFile <- params$countDataFile
colDataFile <- params$colDataFile
gtfFile <- params$gtfFile
caseSampleGroups <- params$caseSampleGroups
controlSampleGroups <- params$controlSampleGroups
covariates <- params$covariates
groupCol <- params$groupCol
prefix <- params$prefix
workdir <- params$workdir
scriptdir <- params$scriptdir
organism <- params$organism
peakFile <- params$peakFile

## load helper functions
source(file.path(scriptdir, 'Functions_Helper.R'))

## convert flags into bools
readFlags <- function(flag) {
    if(is.list(flag)) {
        return(lapply(flag, readFlags))
    } else {
        if (nchar(flag) == 0) flag <- TRUE
        switch(EXPR = tolower(flag),
               "yes" = TRUE,
               "true" = TRUE,
               "false" = FALSE,
               "no" = FALSE,
               flag
        )
    }
}

useCustomBackground <- readFlags(params$useCustomBackground)
rankedQuery <- readFlags(params$rankedQuery)

#gProfiler tool needs internet access to work. So, go analysis module is conditional
runGO <- curl::has_internet() 

#whether to do GO analysis or not
runGO <- TRUE

#if organism is not provided, it is not possible to do GO analysis 
if(organism == '') {
  runGO <- FALSE
}

#create a folder to save high quality images generated by the report script
imagesDir <- file.path(workdir ,paste0(prefix, '_images'))
if(! dir.exists(imagesDir)) { 
  dir.create(path = imagesDir)
}

inputParameterDesc <- c('Count Data File',
                     'Experiment Data File',
                     'GTF File', 
                     'Case sample groups',
                     'Control sample groups', 
                     'Covariates to control for',
                     'Prefix for output files',
                     'Working directory',
                     'Analyzed organism'
                     )
inputParameterValues <- c(countDataFile,
                          colDataFile,
                          gtfFile, 
                          caseSampleGroups,
                          controlSampleGroups, 
                          covariates,
                          prefix,
                          workdir,
                          organism)
inputSettings <- data.frame(parameters = inputParameterDesc,
                            values = inputParameterValues,
                            stringsAsFactors = FALSE)
DT::datatable(data = inputSettings,
              extensions = 'FixedColumns',
              options = list(fixedColumns = TRUE,
                         scrollX = TRUE,
                         pageLength = 9,
                         dom = 't'))
```

```{r import_GTF}
gtfData <- readRDS(gtfFile)
peaks <- rtracklayer::import(peakFile)
```

```{r prepare_inputs_counts_and_coldata}
caseSamples <- gsub(' ', '', unlist(strsplit(x = caseSampleGroups, split = ',')))
controlSamples <- gsub(' ', '', unlist(strsplit(x = controlSampleGroups, split = ',')))
covariates <- gsub(' ', '', unlist(strsplit(x = covariates, split = ',')))
#read colData and countData files
colData = read.table(colDataFile, header=T, row.names = 1, sep='\t', stringsAsFactors = T, check.names = FALSE)
countData = read.table(countDataFile, header=TRUE, row.names=1, sep='\t', stringsAsFactors = T, check.names = FALSE)
colData$group = colData[[groupCol]] 

#subset colData and countData - only keep case and control samples
colData <- colData[colData$group %in% c(caseSamples, controlSamples),]
countData <- subset(countData, select = rownames(colData))

#split samples as case/control for deseq
colData$AnalysisGroup <- 'Control'
colData[colData$group %in% caseSamples,]$AnalysisGroup <- 'Case'
```

# Pre-Processing

## Peak Calling

All peaks were called with [macs2](https://github.com/taoliu/MACS) and the peak consensus set used for this analysis can be found at: 

 - **Peak Consensus File**: 
 `r peakFile`

## Read Counting 

Reads were counted over the given consensus peaks using featureCounts from the [Rsubread package](https://doi.org/10.1093/nar/gkz114), the raw count data can be found at: 

 - **Raw Count Data File**: 
 `r countDataFile`

```{r run_deseq2}

mapIdsToNames <- function(ids, gtf, collapse.char = ":") {
    #check if gene_name is given in gtf file
    if(!"gene_name" %in% names(as.data.frame(head(gtf)))) {
        return(ids)
    }
    pastedIds = FALSE
    # if ids are pasted, we need to split them first
    if(any(grepl(pattern = collapse.char, ids))) {
      pastedIds = TRUE
      sp <- strsplit(ids, split =":")
      origin <- rep(1:length(sp),times = lengths(strsplit(ids, split =":")))
      ids <- unlist(sp)
    }
    
    #first figure out if the given ids are transcript or gene ids
    df <- unique(data.frame('transcript_id' = gtf$transcript_id, 
                            'gene_id' = gtf$gene_id, 
                            'gene_name' = gtf$gene_name, stringsAsFactors = FALSE))
    m <- apply(df[,1:2], 2, function(x) sum(head(ids) %in% x))
    #then map the ids to gene names
    if(m['transcript_id'] > m['gene_id']){
      matches <- df[match(ids, df$transcript_id),]$gene_name
    } else {
      matches <- df[match(ids, df$gene_id),]$gene_name
    }
    
    if(pastedIds) {
      matches = sapply(split(matches, f = origin),
                       paste, collapse=":", simplify = TRUE)
    }
    return(matches)
    
}

mapPeaksToGene <- function(peaks, gtfData, type = 'precedence') {
  
  ## target will be tss of genes 
  annot = AnnotateRanges(peaks, gtfData$genomic_annotation,type = type)
  annotGene = AnnotateRanges(peaks, 
                                   c(gtfData$genomic_annotation$tss,
                                     gtfData$full_annotation$gene),
                             type = type)
  return(list("annot"     = annot,
              "annotGene" = annotGene))

}


if(length(covariates) > 0){
  designFormula <- paste("~", paste(covariates, collapse = ' + '), "+ AnalysisGroup")
} else {
  designFormula <- "~ AnalysisGroup"
}

message("design formula:", designFormula)
dds <- DESeq2::DESeqDataSetFromMatrix(countData = countData, colData = colData, design = stats::as.formula(designFormula))
dds <- dds[ rowSums(counts(dds)) > 1, ]
dds <- DESeq2::DESeq(dds)
norm.counts = DESeq2::counts(dds, normalized = TRUE)

DEtable = DESeq2::results(dds, contrast = c("AnalysisGroup", 'Case', 'Control'))
DEtable <- DEtable[order(DEtable$padj),]
DE <- as.data.frame(DEtable)

mcols(peaks) = cbind(mcols(peaks)["name"], mapPeaksToGene(peaks, gtfData, type = 'all'))
# mcols(peaks) = cbind(mcols(peaks)["name"], mapPeaksToGene(peaks, gtfData, type = 'precedence'))
DE <- cbind(DE,peaks[match(rownames(DE),peaks$name),c("annot", "annotGene")])
DE$geneName <- mapIdsToNames(ids = DE$annotGene, gtf = gtfData$gtf)

DEnormalizedCountsFile <- file.path(workdir, paste0(prefix, '.normalized_counts.tsv'))
write.table(x = norm.counts, 
            file = DEnormalizedCountsFile, 
            quote = FALSE, sep = '\t')
            
DEresultsFile <- file.path(workdir, paste0(prefix, '.deseq_results.tsv'))             
write.table(x = DE, 
            file = DEresultsFile, 
            quote = FALSE, sep = '\t')

DP <- DE[!is.na(DE$padj) & DE$padj < 0.1 & DE$log2FoldChange > 0,]
if(nrow(DP) > 0) {
  DEPeakFile <- file.path(workdir, paste0(prefix, '.deseq_peaks.bed')) 
  DP$name <- rownames(DP)
  write.table(x =  DP[,c("seqnames","start","end","name")], 
              file = DEPeakFile, 
              quote = FALSE, sep = '\t')
}

```

# Differential Binding/Accessibilty Analysis

Differential binding or accessibility analysis (DA) was done using the [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) R package. First, read counts are transformed using a _variance stabilizing transformation_, and then the expression values of each gene is compared between the control and sample groups using a negative binomial distribution as a model.

## Differential Expression Results Table (top 1000)

This is the table of top 1000 differentially occupied peaks comparing cases to controls (as specified in the input settings listed above). The table is first filtered by absolute log2foldChange > 1 and sorted by adjusted P value after multiple testing correction (`padj`). The `baseMean` refers to expression level in the controls, and the log fold change column denotes the expression in the cases, as compared to the control. 

The full table of DESeq2 results and normalized counts tables can be found at: 
 
 - **DESeq2 results table**: 
 `r DEresultsFile`
 - **DESeq2 normalized counts table**: 
 `r DEnormalizedCountsFile`

```{r write_DEtable}
DEsubset <- DE[!is.na(DE$padj) & abs(DE$log2FoldChange) > 1,]
max <- 1000
if(nrow(DEsubset) < max) {
max <- nrow(DEsubset)
}
DEsubset <- DEsubset[1:max,]

DT::datatable(DEsubset, 
          extensions = c('Buttons', 'FixedColumns', 'Scroller'), 
          options = list(fixedColumns = TRUE, 
                         scrollY = 400,
                         scrollX = TRUE,
                         scroller = TRUE,
                         dom = 'Bfrtip',
                         buttons = c('colvis', 'copy', 'print', 'csv','excel', 'pdf'),
                         columnDefs = list(
                           list(targets = c(3,4,5,7,8,9,10,11,12,13), visible = FALSE)
                         )),
          filter = 'bottom'
          ) %>% formatRound(c('baseMean','log2FoldChange'), 3) %>% formatSignif('padj', 2)
```


# Diagnostic Plots 

This section holds a number of plots meant for a quick diagnostic and/or sanity check of the analysis.

## Number of reads assigned to peaks 

This plot shows the number of reads, in each sample, that are assigned to peaks. Outlier samples may be faulty and should be examined.

```{r plot_readcounts}
readCounts <- as.data.frame(colSums(countData))
readCounts$group <- colData[rownames(readCounts),]$group
readCounts$sample <- rownames(readCounts)
colnames(readCounts)[1] <- 'readCounts'

quantiles <- quantile(readCounts$readCounts, c(1:20)/20)[c(1,5,15,19)]

p <- ggplot(readCounts, aes(x = sample, y = readCounts)) + geom_bar(aes(fill = group), stat = 'identity') + 
  geom_hline(yintercept = as.numeric(quantiles), color = 'red') +
  geom_label_repel(data = data.frame(x = 0, y = as.numeric(quantiles)), aes(x = x, y = y, label = names(quantiles))) + theme(legend.position = 'bottom') + scale_y_continuous(labels = scales::comma) +  coord_flip()
print(p)
#save image to folder
pdf(file = file.path(imagesDir, 'readcounts.pdf'))
print(p)
invisible(dev.off())
```

## p-value histogram

The P value distribution from the DE analysis. The expected shape depends on the expected difference / similarity between the controls and samples.

```{r plot_pvalhistogram}
p <- ggplot(data = DE, aes(x = pvalue)) + geom_histogram(bins = 100)
print(p)
#save image to folder
pdf(file = file.path(imagesDir, 'pvalue_histogram.pdf'))
print(p)
invisible(dev.off())
```

## MA plot

The MA plot gives an overview of the comparison between the two groups in the experiment. The log2 fold change for each peak is plotted on the y axis, against the average expression of that gene on the x axis.

```{r plot_MA}
DESeq2::plotMA(DEtable, main=paste("MA plot"), ylim=c(-6,6),)
#save image to folder
pdf(file = file.path(imagesDir, 'MA_plot.pdf'))
DESeq2::plotMA(DEtable, main=paste("MA plot"), ylim=c(-6,6))
invisible(dev.off())
```


```{r computePCAplots} 
plotGroups <- c(covariates, 'AnalysisGroup', 'group')
plotGroups <- plotGroups[nchar(plotGroups)>0]
pcaPlots <- lapply(plotGroups, function(g) {
  pca <- stats::prcomp(t(norm.counts), center = TRUE)
  pcaSummary <- summary(pca)
  df <- merge(as.data.frame(pca$x), colData, by = 'row.names')
  ggplot(df, aes(x = PC1, y = PC2)) + 
    geom_point(aes_string(color = g)) + 
    geom_label_repel(aes(label = Row.names), size = 3) + 
    labs(x = paste0('PC1 (',round(pcaSummary$importance[2, 'PC1'] * 100, 1),'%)'), 
         y = paste0('PC2 (',round(pcaSummary$importance[2, 'PC2'] * 100, 1),'%)')) + 
    theme_bw()
})
#save image to folder
pdf(file = file.path(imagesDir, 'pcaPlots.pdf'))
for(p in pcaPlots){
  print(p)  
}
invisible(dev.off())
```

## PCA plots  {.tabset}

The 2-dimensional principal component analysis plot shows which samples group together when plotted in a reduced dimension. The 2D PCA reduced dimension conserves as much of the variance in the dataset as is possible for any 2D embedding of the data. It provides a useful birds-eye view of the data and an intuition as to which factors may drive the differences between samples or groups.

```{r plotPCA, results='asis', echo = FALSE}
for (i in 1:length(pcaPlots)) {
  cat("### ",plotGroups[i],"\n")
  print(pcaPlots[[i]])
  cat('\n\n')
}
```

## Correlation Plot

The pairwise correlation plot provides a more detailed view of which samples are more similar or different.

```{r plot_corr}
M <- stats::cor(norm.counts)
# corrplot::corrplot(corr = M, order = 'hclust', method = 'square', type = 'lower', tl.srt = 45, addCoef.col = 'white')
df <- as.data.frame(colData[,c("group","AnalysisGroup")])
pheatmap::pheatmap(M,
                   annotation_col=df)
#save image to folder
pdf(file = file.path(imagesDir, 'correlationPlot.pdf'))
# corrplot::corrplot(corr = M, order = 'hclust', method = 'square', type = 'lower', tl.srt = 45, addCoef.col = 'white')
pheatmap::pheatmap(M,
                   annotation_col=df)
invisible(dev.off())
```

## Heatmaps {.tabset}

### Top 100 most highly variable peaks

The heatmap below summarizes the experiment, and the apparent relationship between samples, based on the 100 highest variance peaks. Each column is a sample, and each row is a peak. Both rows and columns are clustered using euclidean distance and complete linkage.

```{r plot_heatmap}
select <- na.omit(names(sort(apply(X = norm.counts, MARGIN = 1, FUN = var),decreasing = T))[1:100])

df <- as.data.frame(colData[,c("group","AnalysisGroup")])
pheatmap::pheatmap(norm.counts[select,], 
         scale = 'row',
         cluster_rows=TRUE, 
         show_rownames=FALSE, 
         cluster_cols=TRUE, 
         annotation_col=df, 
         main = 'Heatmap of the Normalized Coverage Values of \n Top 100 Peaks with highest variance across samples')
#save image to folder
pdf(file = file.path(imagesDir, 'heatmap.pdf'))
pheatmap::pheatmap(norm.counts[select,], 
         scale = 'row',
         cluster_rows=TRUE, 
         show_rownames=FALSE, 
         cluster_cols=TRUE, 
         annotation_col=df, 
         main = 'Heatmap of the Normalized Coverage Values of \n Top 100 Peaks with highest variance across samples')
invisible(dev.off())
```

```{r results='asis'}
showSigPeaks <- nrow(DEsubset) > 5
if(showSigPeaks == FALSE) {cat("Warning:Skipping differential peaks as there is not enough sites.\n")}
```

```{r text_SigDiff_heatmap, eval = showSigPeaks, results='asis'}
cat("### Top 100 most significant differential peaks\n")
cat("\n The heatmap below summarizes the differential analysis, based on the 100 most differential peaks. Each column is a sample, and each row is a peak. Both rows and columns are clustered using euclidean distance and complete linkage.")
```


```{r plot_SigDiff_heatmap, eval = showSigPeaks}
select <- na.omit(rownames(DEtable[order(DEtable$padj, decreasing = FALSE),])[1:100])

df <- as.data.frame(colData[,c("group","AnalysisGroup")])
pheatmap::pheatmap(norm.counts[select,], 
         scale = 'row',
         cluster_rows=TRUE, 
         show_rownames=FALSE, 
         cluster_cols=TRUE, 
         annotation_col=df, 
         main = 'Heatmap of the Normalized Coverage Values of \n Top 100 most significant differential Peaks across samples')
#save image to folder
pdf(file = file.path(imagesDir, 'heatmap_diffPeaks.pdf'))
pheatmap::pheatmap(norm.counts[select,], 
         scale = 'row',
         cluster_rows=TRUE, 
         show_rownames=FALSE, 
         cluster_cols=TRUE, 
         annotation_col=df, 
         main = 'Heatmap of the Normalized Coverage Values of \n Top 100 most significant differential Peaks across samples')
invisible(dev.off())
```

# Exploratory Plots and Tables

## Summary of up/down regulated genes - volcano plot

This volcano plot summarizes the differential expression landscape in the comparison between the two groups.

```{r plot_summary_volcano}
p <- ggplot(DE, aes(x = log2FoldChange, y = -log10(pvalue))) + geom_point(aes(color = padj < 0.1))
print(p)
#save image to folder
pdf(file = file.path(imagesDir, 'volcanoPlot.pdf'))
print(p)  
invisible(dev.off())
```

## Summary of up/down regulated peaks - bar plots

These bar plots summarizes the number of significantly upregulated/downregulated number of peaks based on
different adjusted p-value (selected adjusted p-values are 0.001, 0.01, 0.05, and 0.1 - see facet headers) and log2 fold change thresholds (on the x-axis) used to define the significance levels. 

```{r plot_summary_barplots}

filterUP <- function(df, log2fc = 1, p = 0.1) {nrow(df[df$log2FoldChange >= log2fc & !is.na(df$padj) & df$padj <= p,])}
filterDOWN <- function(df, log2fc = 1, p = 0.1) {nrow(df[df$log2FoldChange < -log2fc & !is.na(df$padj) & df$padj <= p,])}

pVals <- c(0.001, 0.01, 0.05, 0.1)
fcVals <- c(0:(max(DE$log2FoldChange)+1))

summary <- do.call(rbind, lapply(pVals, function(p) {
  do.call(rbind, lapply(fcVals, function(f){
    up <- filterUP(DE, f, p)
    down <- filterDOWN(DE, f, p)
    return(data.frame("log2FoldChange" = f, "padj" = p, 
                      "upRegulated" = up, "downRegulated" = down))
  }))
}))

mdata <- reshape2::melt(summary, id.vars = c('log2FoldChange', 'padj'))

p <- ggplot(mdata, aes(x = log2FoldChange, y = value)) + geom_bar(aes(fill = variable), stat = 'identity', position = 'dodge') + facet_grid(~ padj) + theme(legend.position = 'bottom', legend.title = element_blank()) + labs(title = 'Number of differentially up/down regulated peaks', subtitle = 'based on different p-value and log2foldChange cut-off values')
print(p)
#save image to folder
pdf(file = file.path(imagesDir, 'up_down_regulated_genes_summary.pdf'))
print(p)
invisible(dev.off())
```

## Interactive box plots of genes with significant differential occupancy 

This interactive plot lets you see peaks' position in the volcano plot, as well as their expression levels in the cases and the controls (in the box plot on the left side). Use the search box to find genes of interest. Notice that only top 1000 peaks that have an adjusted p-value less than 0.1 and absolute log2 fold change value of greater than 1 are plotted. 

```{r plot_interactive_boxplots}
select <- rownames(DEsubset)
if(length(select) > 1) {
  expressionLevels <- reshape2::melt(norm.counts[select,])
  colnames(expressionLevels) <- c('geneId', 'sampleName', 'expressionLevel')
  
  expressionLevels$group <- colData[expressionLevels$sampleName,]$group
  expressionLevels$AnalysisGroup <- colData[expressionLevels$sampleName,]$AnalysisGroup
  
  matchIds <- match(expressionLevels$geneId, rownames(DE))
  expressionLevels$padj <- DE[matchIds,]$padj
  expressionLevels$log2FoldChange <- DE[matchIds,]$log2FoldChange
  expressionLevels$geneName <- DE[matchIds,]$geneName
  
  expressionLevels$text <- with(expressionLevels,
                                paste("Peak:", geneId, 
                                      "<br> Annotated Gene:", geneName,
                                      "<br> log2FoldChange:", round(log2FoldChange,digits = 2),
                                      "<br>"))
  
  sd <- SharedData$new(expressionLevels, ~geneId)
  
  lineplot <- plot_ly(sd, x = ~sampleName, y = ~expressionLevel) %>%
    group_by(geneId) %>% 
    add_lines(text = ~geneId, hoverinfo = "text", color = ~AnalysisGroup)
  
  volcanoPlot <- plot_ly(sd, x = ~log2FoldChange, y = ~-log10(padj)) %>% 
      add_markers(text = ~text, hoverinfo = "text")
      # add_markers(hovertemplate = "Peak: (%{~geneId}) <br> Annotated Gene: %{~geneName} <br>")
  
  subplot(
  plot_ly(sd, y = ~expressionLevel, color = ~AnalysisGroup) %>% 
      add_boxplot(),  
  volcanoPlot
  ) %>% highlight(on =  'plotly_click', off = 'plotly_doubleclick', selectize = TRUE)
} else {
  cat("Couldn't detect at least two peaks satisfying the p-value and fold change thresholds\n")
}

```


```{r results='asis'}
if(runGO == FALSE) {
  cat("Warning:Skipping GO analysis because `organism` option is not set in settings.yaml file\n")
} else if (curl::has_internet() == FALSE){
  #gProfiler tool needs internet access to work. So, go analysis module is conditional
  runGO <- FALSE
  cat("Warning:Skipping GO analysis as there is no internet connection to query https://biit.cs.ut.ee/gprofiler/\n")
}
```

```{r goAnalysisTitle, eval = runGO, results='asis'}
cat("# GO Term Enrichment Analysis\n")
cat("\n The following tables list GO terms for up- and down-regulated peaks GO term analysis was carried out using [g:Profiler](https://cran.r-project.org/web/packages/gProfileR/) R package. Up-regulated peaks are defined as those peaks with adjusted p-value of less than 0.1 and log2 fold change value of greater than 0. Down-regulated peaks are defined as those genes with adjusted p-value of less than 0.1 and log2 fold change of less than 0.")
```

```{r goAnalysis, eval = runGO}

geneOrPeakUp <-  with(
  DE[!is.na(DE$padj) & DE$padj < 0.1 & DE$log2FoldChange > 0, ],
  if(annotGene != "None") unique(unlist(strsplit(annotGene,":")))
  else sprintf("%s:%s:%s",seqnames,start,end))

geneOrPeakDown <- with(
  DE[!is.na(DE$padj) & DE$padj < 0.1 & DE$log2FoldChange < 0, ],
  if(annotGene != "None") unique(unlist(strsplit(annotGene,":")))
  else sprintf("%s:%s:%s",seqnames,start,end))

genesBG.region <-  with(
  DE,
  sprintf("%s:%s:%s",seqnames,start,end))


```

```{r goAnalysisRun, eval = runGO}

Up <- geneOrPeakUp
Down <- geneOrPeakDown

# gprofiler fails if list is empty
if( length(Up) == 0) Up = ""
if( length(Down) == 0) Down = ""

gProf <- gprofiler2::gost(query = list( "Up" = Up,
                                       "Down" = Down),
                         custom_bg = if(useCustomBackground) {
                           genesBG.region
                           } else NULL,
                         organism = organism,
                         ordered_query = rankedQuery,
                         significant = TRUE,
                         evcodes = TRUE,
                         multi_query = FALSE,
                         domain_scope = ifelse(useCustomBackground,
                                               "custom_annotated",
                                               "annotated"),
                         correction_method = "g_SCS"
                         # sources = c('GO', 'KEGG', 'REAC', 'CORUM')
)


if(is.null(gProf)) runGO <- FALSE
```

```{r results='asis'}
if(runGO == FALSE) {
  cat("Warning:GO analysis did produce any results.\n")
} else {
  cat("\n The full table of GO Term Enrichment Analysis results and corresponding metadata can be found at: 
 
 - **g:Profiler2 results table**: 
 ", file.path(workdir, paste0(prefix, '.GOterms.tsv')), "
 - **g:Profiler2 metadata file**: 
 ", file.path(workdir, paste0(prefix, '.GOterms_meta.RDS')), " \n")
  
  cat("\n The version of g:Profiler producing the following results was <",paste0("`",gProf$meta$version,"`")," >. You may access archived versions of g:Profiler via the [website](https://biit.cs.ut.ee/gprofiler/page/archives) or the [R-Client](https://cran.r-project.org/web/packages/gprofiler2/vignettes/gprofiler2.html#accessing-archived-versions-or-the-beta-release-with-set_base_url). \n")
}
```

```{r goAnalysisResults, eval = runGO}
#order by p-value
goResults <- gProf$result[order(gProf$result$p_value),]
goResults$parents <- sapply(goResults$parents, paste,collapse = " ")

#save full GO term table to disk 
goResultsFile <- file.path(workdir, paste0(prefix, '.GOterms.tsv'))
write.table(x = goResults, 
            file = goResultsFile, 
            quote = FALSE, sep = '\t')
saveRDS(gProf$meta, file = file.path(workdir, paste0(prefix, '.GOterms_meta.RDS')))

#only display top GO terms in the HTML report.
max <- ifelse(nrow(goResults) > 1000, 1000, nrow(goResults))

DT::datatable(goResults[1:max,], 
        extensions = c('Buttons', 'FixedColumns', 'Scroller'), 
        options = list(fixedColumns = TRUE, 
                       scrollY = 400,
                       scrollX = TRUE,
                       scroller = TRUE,
                       dom = 'Bfrtip',
                       buttons = c('colvis', 'copy', 'print', 'csv','excel', 'pdf'), 
                       columnDefs = list(
                         list(targets = c(0,2,5,7,8,9,12,13,14,15,16), visible = FALSE)
                       )
                       ),
        filter = 'bottom'
        ) %>% formatSignif(c('precision','recall','p_value'), 3)
```


# Session Information
```{r sessionInfo}
sessionInfo()
```


